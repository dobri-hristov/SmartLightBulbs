"use strict";(self.webpackChunksmart_light_bulbs=self.webpackChunksmart_light_bulbs||[]).push([[4585],{4585:function(e,n,t){t.d(n,{c:function(){return g},u:function(){return y}});var o=t(9439),r=t(8134),i=t(889),a=t(7411),s=t(8529),l=t(553),c=t(7142),u=function(e){return"\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n".concat(e?"varying float yPositionPx;":"","\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  ").concat(e?"yPositionPx = positionPx.y;":"","\n}\n")},h="\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND ".concat(i.M,"\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n"),d=function(e){var n=e.viewport,t=n.end,o=n.start,r=n.yMax,i=n.yMin,a=e.toClipSpace,s=e.size,l=s.width,c=s.height;return{x:Math.abs((a(t.getTime())-a(o.getTime()))/l),y:Math.abs((r-i)/c)}},p=s.S,f=function(e,n,t){var r=e.filter(l.b).map((function(e){return(0,a.v)(e,e.resolution)}));n.count=function(e){return e.reduce((function(e,n){return e+Math.max(n.length,0)}),0)}(r);var i=n.geometry.attributes,s=i.currPoint,c=i.nextPoint,u=i.segmentColor,h=0,d=0;r.forEach((function(e){e.forEach((function(n,r){var i=r===e.length-1?n:e[r+1],a=(0,o.Z)(n,5),l=a[0],p=a[1],f=a[2],v=a[3],m=a[4],g=(0,o.Z)(i,2),y=g[0],x=g[1];s.array[h]=t(l),s.array[h+1]=p,c.array[h]=t(y),c.array[h+1]=x,u.array[d]=f,u.array[d+1]=v,u.array[d+2]=m,d+=3,h+=2}))})),s.needsUpdate=!0,c.needsUpdate=!0,u.needsUpdate=!0},v=[[0,-.5],[1,-.5],[1,.5],[0,-.5],[1,.5],[0,.5]],m=function(e){var n=e.viewport,t=e.dataStreams,o=e.chartSize,s=e.minBufferSize,l=e.bufferFactor,c=e.toClipSpace,m=e.thresholdOptions,g=e.thresholds,y=new r.I,x=Math.max(s,(0,a.n)(t)*l);!function(e,n){e.setAttribute("position",new r.B(new Float32Array(v.flat()),2)),e.setAttribute("currPoint",new r.b(new Float32Array(2*n),2,!1)),e.setAttribute("nextPoint",new r.b(new Float32Array(2*n),2,!1)),e.setAttribute("segmentColor",new r.b(new Uint8Array(3*n),3,!0))}(y,x);var w=d({viewport:n,toClipSpace:c,size:o}),P=w.x,b=w.y,S=m.showColor,C=void 0===S||S,_=new r.R({vertexShader:u(C&&g.length>0),fragmentShader:C&&0!==g.length?h:"\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n",side:r.D,transparent:!0,uniforms:{width:{value:p},xPixelDensity:{value:P},yPixelDensity:{value:b},thresholdBands:{value:(0,i.t)(g)}}}),B=new r.a(y,_,x);return B.frustumCulled=!1,f(t,B,c),B},g=function(e){var n=e.dataStreams,t=e.chartSize,o=e.container,s=e.viewport,l=e.minBufferSize,u=e.bufferFactor,h=e.onUpdate,d=e.thresholdOptions,p=e.thresholds,f=new r.S,v=(0,a.a)(s),g=(0,c.a)(p),y=[];return y[1]=m({toClipSpace:v,chartSize:t,dataStreams:n,viewport:s,minBufferSize:l,bufferFactor:u,thresholdOptions:d,thresholds:g}),y[i.P]=(0,i.p)({dataStreams:n,minBufferSize:l,bufferFactor:u,toClipSpace:v,thresholdOptions:d,thresholds:g}),y.forEach((function(e){return f.add(e)})),(0,a.c)({scene:f,viewport:s,container:o,toClipSpace:v,onUpdate:h})},y=function(e){var n=e.scene,t=e.dataStreams,o=e.chartSize,r=e.container,s=e.viewport,l=e.hasDataChanged,c=e.bufferFactor,u=e.minBufferSize,h=e.onUpdate,p=e.thresholdOptions,v=e.hasAnnotationChanged,m=e.thresholds,y=n.scene.children[1],x=n.scene.children[i.P],w=function(e){return e.geometry.attributes.position.array.length/i.N}(x)<(0,a.n)(t);return w||(0,a.b)(s,n.toClipSpace)||v?g({dataStreams:t,chartSize:o,container:r,viewport:s,minBufferSize:u,bufferFactor:c,onUpdate:h,thresholdOptions:p,thresholds:m}):(function(e){var n=e.chartSize,t=e.toClipSpace,o=e.lines,r=e.dataStreams,i=e.viewport,a=e.hasDataChanged,s=d({viewport:i,toClipSpace:t,size:n}),l=s.x,c=s.y;o.material.uniforms.xPixelDensity.value=l,o.material.uniforms.yPixelDensity.value=c,a&&f(r,o,t)}({lines:y,dataStreams:t,chartSize:o,viewport:s,hasDataChanged:l,toClipSpace:n.toClipSpace}),(0,i.u)(t,x,n.toClipSpace,l),n)}},8529:function(e,n,t){t.d(n,{S:function(){return o},g:function(){return r}});var o=1.5,r=function(e){return e.map((function(e){return{id:e.id,name:e.name,detailedName:e.detailedName,color:e.color,unit:e.unit,dataType:e.dataType,streamType:e.streamType,associatedStreams:e.associatedStreams,isLoading:e.isLoading,isRefreshing:e.isRefreshing,error:e.error,resolution:e.resolution}}))}},889:function(e,n,t){t.d(n,{M:function(){return u},N:function(){return v},P:function(){return p},p:function(){return g},t:function(){return h},u:function(){return y}});var o=t(9439),r=t(8134),i=t(7411),a=t(7142),s=t(7775),l=t(553),c=function(e){return"\nvarying vec3 vColor;\n".concat(e?"varying float positionY;":"","\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  ").concat(e?"positionY = position.y;":"","\n}\n")},u=13,h=function(e){if(0===e.length)return[];var n=(0,a.a)(e),t=(0,a.s)(n).reverse(),r=[],l=new Set;t.forEach((function(e,n){var c=e.value;if(t[n].comparisonOperator!==s.C.EQUAL)if(0!==n){var u=t[n-1],h=u.value,d=(h+c)/2,p=(0,a.g)(d,t);if(null!=p&&!l.has(u.value)){var f=(0,i.g)(p.color),v=(0,o.Z)(f,3),m=v[0],g=v[1],y=v[2];u.comparisonOperator===s.C.EQUAL&&(u.value,t[n].value),r.push({upper:h,lower:c,color:[m,g,y]}),l.add(u.value)}if(n!==t.length-1){var x=t[n+1].value;if(d=(c+x)/2,null!=(p=(0,a.g)(d,t))&&!l.has(c)){var w=(0,i.g)(p.color),P=(0,o.Z)(w,3),b=P[0],S=P[1],C=P[2];r.push({upper:c,lower:x,color:[b,S,C]}),l.add(e.value)}}else if(d=(c+Number.MIN_SAFE_INTEGER)/2,null!=(p=(0,a.g)(d,t))&&!l.has(c)){var _=(0,i.g)(p.color),B=(0,o.Z)(_,3),A=B[0],E=B[1],T=B[2];r.push({lower:Number.MIN_SAFE_INTEGER,upper:c,color:[A,E,T]})}}else{var D=(Number.MAX_SAFE_INTEGER+c)/2,M=(0,a.g)(D,t);if(null!=M){var N=(0,i.g)(M.color),R=(0,o.Z)(N,3),F=R[0],O=R[1],z=R[2];r.push({upper:Number.MAX_SAFE_INTEGER,lower:c,color:[F,O,z]})}}else{var U=(0,i.g)(t[n].color),L=(0,o.Z)(U,3),q=L[0],H=L[1],I=L[2];r.push({upper:c,lower:c,color:[q,H,I]})}}));for(var c=r[r.length-1];r.length<u;){var h=t[t.length-1].value,d=Number.MIN_SAFE_INTEGER+h/2,p=(0,a.g)(d,t);if(null==p)r.push(c);else{var f=(0,i.g)(p.color),v=(0,o.Z)(f,3),m=v[0],g=v[1],y=v[2];c={lower:Number.MIN_SAFE_INTEGER,upper:h,color:[m,g,y]},r.push(c)}}return r},d="\n#define MAX_NUM_TOTAL_THRESHOLD_BAND ".concat(u,"\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n"),p=0,f=function(e){return 0===(null!=e[0]?e[0].resolution:null)?4:6.25},v=2,m=function(e,n,t){var r=n.filter(l.b).map((function(e){return(0,i.v)(e,e.resolution)})).flat(),a=e.attributes,s=a.position,c=a.pointColor;r.forEach((function(e,n){var r=(0,o.Z)(e,5),i=r[0],a=r[1],l=r[2],u=r[3],h=r[4];s.array[n*v]=t(i),s.array[n*v+1]=a,c.array[3*n]=l,c.array[3*n+1]=u,c.array[3*n+2]=h})),e.setDrawRange(0,r.length),s.needsUpdate=!0,c.needsUpdate=!0},g=function(e){var n=e.toClipSpace,t=e.dataStreams,o=e.minBufferSize,a=e.bufferFactor,s=e.thresholdOptions,l=e.thresholds,u=Math.max(o,(0,i.n)(t)*a),p=new r.c;!function(e,n){e.setAttribute("position",new r.B(new Float32Array(n*v),v)),e.setAttribute("pointColor",new r.B(new Uint8Array(3*n),3,!0))}(p,u),m(p,t,n);var g=s.showColor,y=void 0===g||g,x=new r.d({vertexShader:c(y&&l.length>0),fragmentShader:y&&0!==l.length?d:"\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n",transparent:!0,uniforms:{pointDiameter:{value:f(t)},devicePixelRatio:{value:window.devicePixelRatio},thresholdBands:{value:h(l)}}}),w=new r.P(p,x);return w.frustumCulled=!1,w},y=function(e,n,t){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];n.material.uniforms.pointDiameter.value=f(e),n.material.uniforms.devicePixelRatio.value=window.devicePixelRatio,o&&m(n.geometry,e,t)}}}]);
//# sourceMappingURL=4585.7ada2b9e.chunk.js.map