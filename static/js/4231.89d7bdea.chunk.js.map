{"version":3,"file":"static/js/4231.89d7bdea.chunk.js","mappings":"yQAUIA,EAAW,WACX,GAAmB,qBAARC,IACP,OAAOA,IASX,SAASC,EAASC,EAAKC,GACnB,IAAIC,GAAU,EAQd,OAPAF,EAAIG,MAAK,SAAUC,EAAOC,GACtB,OAAID,EAAM,KAAOH,IACbC,EAASG,GACF,EAGf,IACOH,CACX,CACA,OAAsB,WAClB,SAASI,IACLC,KAAKC,YAAc,EACvB,CAsEA,OArEAC,OAAOC,eAAeJ,EAAQK,UAAW,OAAQ,CAI7CC,IAAK,WACD,OAAOL,KAAKC,YAAYK,MAC5B,EACAC,YAAY,EACZC,cAAc,IAMlBT,EAAQK,UAAUC,IAAM,SAAUX,GAC9B,IAAII,EAAQN,EAASQ,KAAKC,YAAaP,GACnCG,EAAQG,KAAKC,YAAYH,GAC7B,OAAOD,GAASA,EAAM,EAC1B,EAMAE,EAAQK,UAAUK,IAAM,SAAUf,EAAKgB,GACnC,IAAIZ,EAAQN,EAASQ,KAAKC,YAAaP,IAClCI,EACDE,KAAKC,YAAYH,GAAO,GAAKY,EAG7BV,KAAKC,YAAYU,KAAK,CAACjB,EAAKgB,GAEpC,EAKAX,EAAQK,UAAUQ,OAAS,SAAUlB,GACjC,IAAImB,EAAUb,KAAKC,YACfH,EAAQN,EAASqB,EAASnB,IACzBI,GACDe,EAAQC,OAAOhB,EAAO,EAE9B,EAKAC,EAAQK,UAAUW,IAAM,SAAUrB,GAC9B,SAAUF,EAASQ,KAAKC,YAAaP,EACzC,EAIAK,EAAQK,UAAUY,MAAQ,WACtBhB,KAAKC,YAAYa,OAAO,EAC5B,EAMAf,EAAQK,UAAUa,QAAU,SAAUC,EAAUC,QAChC,IAARA,IAAkBA,EAAM,MAC5B,IAAK,IAAIC,EAAK,EAAGC,EAAKrB,KAAKC,YAAamB,EAAKC,EAAGf,OAAQc,IAAM,CAC1D,IAAIvB,EAAQwB,EAAGD,GACfF,EAASI,KAAKH,EAAKtB,EAAM,GAAIA,EAAM,GACvC,CACJ,EACOE,CACX,CA1EO,EA2EX,CAjGe,GAsGXwB,EAA8B,qBAAXC,QAA8C,qBAAbC,UAA4BD,OAAOC,WAAaA,SAGpGC,EACsB,qBAAXC,EAAAA,GAA0BA,EAAAA,EAAOC,OAASA,KAC1CD,EAAAA,EAES,qBAATE,MAAwBA,KAAKD,OAASA,KACtCC,KAEW,qBAAXL,QAA0BA,OAAOI,OAASA,KAC1CJ,OAGJM,SAAS,cAATA,GASPC,EACqC,oBAA1BC,sBAIAA,sBAAsBC,KAAKP,GAE/B,SAAUR,GAAY,OAAOgB,YAAW,WAAc,OAAOhB,EAASiB,KAAKC,MAAQ,GAAG,IAAO,GAAK,EAqE7G,IAGIC,EAAiB,CAAC,MAAO,QAAS,SAAU,OAAQ,QAAS,SAAU,OAAQ,UAE/EC,EAAwD,qBAArBC,iBAInCC,EAA0C,WAM1C,SAASA,IAMLxC,KAAKyC,YAAa,EAMlBzC,KAAK0C,sBAAuB,EAM5B1C,KAAK2C,mBAAqB,KAM1B3C,KAAK4C,WAAa,GAClB5C,KAAK6C,iBAAmB7C,KAAK6C,iBAAiBZ,KAAKjC,MACnDA,KAAK8C,QAjGb,SAAmB5B,EAAU6B,GACzB,IAAIC,GAAc,EAAOC,GAAe,EAAOC,EAAe,EAO9D,SAASC,IACDH,IACAA,GAAc,EACd9B,KAEA+B,GACAG,GAER,CAQA,SAASC,IACLtB,EAAwBoB,EAC5B,CAMA,SAASC,IACL,IAAIE,EAAYnB,KAAKC,MACrB,GAAIY,EAAa,CAEb,GAAIM,EAAYJ,EA7CN,EA8CN,OAMJD,GAAe,CACnB,MAEID,GAAc,EACdC,GAAe,EACff,WAAWmB,EAAiBN,GAEhCG,EAAeI,CACnB,CACA,OAAOF,CACX,CA4CuBG,CAASvD,KAAK8C,QAAQb,KAAKjC,MAzC9B,GA0ChB,CA+JA,OAxJAwC,EAAyBpC,UAAUoD,YAAc,SAAUC,IACjDzD,KAAK4C,WAAWc,QAAQD,IAC1BzD,KAAK4C,WAAWjC,KAAK8C,GAGpBzD,KAAKyC,YACNzC,KAAK2D,UAEb,EAOAnB,EAAyBpC,UAAUwD,eAAiB,SAAUH,GAC1D,IAAII,EAAY7D,KAAK4C,WACjB9C,EAAQ+D,EAAUH,QAAQD,IAEzB3D,GACD+D,EAAU/C,OAAOhB,EAAO,IAGvB+D,EAAUvD,QAAUN,KAAKyC,YAC1BzC,KAAK8D,aAEb,EAOAtB,EAAyBpC,UAAU0C,QAAU,WACnB9C,KAAK+D,oBAIvB/D,KAAK8C,SAEb,EASAN,EAAyBpC,UAAU2D,iBAAmB,WAElD,IAAIC,EAAkBhE,KAAK4C,WAAWqB,QAAO,SAAUR,GACnD,OAAOA,EAASS,eAAgBT,EAASU,WAC7C,IAOA,OADAH,EAAgB/C,SAAQ,SAAUwC,GAAY,OAAOA,EAASW,iBAAmB,IAC1EJ,EAAgB1D,OAAS,CACpC,EAOAkC,EAAyBpC,UAAUuD,SAAW,WAGrCpC,IAAavB,KAAKyC,aAMvBhB,SAAS4C,iBAAiB,gBAAiBrE,KAAK6C,kBAChDrB,OAAO6C,iBAAiB,SAAUrE,KAAK8C,SACnCR,GACAtC,KAAK2C,mBAAqB,IAAIJ,iBAAiBvC,KAAK8C,SACpD9C,KAAK2C,mBAAmB2B,QAAQ7C,SAAU,CACtC8C,YAAY,EACZC,WAAW,EACXC,eAAe,EACfC,SAAS,MAIbjD,SAAS4C,iBAAiB,qBAAsBrE,KAAK8C,SACrD9C,KAAK0C,sBAAuB,GAEhC1C,KAAKyC,YAAa,EACtB,EAOAD,EAAyBpC,UAAU0D,YAAc,WAGxCvC,GAAcvB,KAAKyC,aAGxBhB,SAASkD,oBAAoB,gBAAiB3E,KAAK6C,kBACnDrB,OAAOmD,oBAAoB,SAAU3E,KAAK8C,SACtC9C,KAAK2C,oBACL3C,KAAK2C,mBAAmBiC,aAExB5E,KAAK0C,sBACLjB,SAASkD,oBAAoB,qBAAsB3E,KAAK8C,SAE5D9C,KAAK2C,mBAAqB,KAC1B3C,KAAK0C,sBAAuB,EAC5B1C,KAAKyC,YAAa,EACtB,EAQAD,EAAyBpC,UAAUyC,iBAAmB,SAAUxB,GAC5D,IAAIwD,EAAKxD,EAAGyD,aAAcA,OAAsB,IAAPD,EAAgB,GAAKA,EAEvCxC,EAAezC,MAAK,SAAUF,GACjD,SAAUoF,EAAapB,QAAQhE,EACnC,KAEIM,KAAK8C,SAEb,EAMAN,EAAyBuC,YAAc,WAInC,OAHK/E,KAAKgF,YACNhF,KAAKgF,UAAY,IAAIxC,GAElBxC,KAAKgF,SAChB,EAMAxC,EAAyBwC,UAAY,KAC9BxC,CACX,CAjM8C,GA0M1CyC,EAAsB,SAAUC,EAAQC,GACxC,IAAK,IAAI/D,EAAK,EAAGC,EAAKnB,OAAOkF,KAAKD,GAAQ/D,EAAKC,EAAGf,OAAQc,IAAM,CAC5D,IAAI1B,EAAM2B,EAAGD,GACblB,OAAOC,eAAe+E,EAAQxF,EAAK,CAC/BgB,MAAOyE,EAAMzF,GACba,YAAY,EACZ8E,UAAU,EACV7E,cAAc,GAEtB,CACA,OAAO0E,CACX,EAQII,EAAe,SAAUJ,GAOzB,OAHkBA,GAAUA,EAAOK,eAAiBL,EAAOK,cAAcC,aAGnD9D,CAC1B,EAGI+D,EAAYC,EAAe,EAAG,EAAG,EAAG,GAOxC,SAASC,EAAQjF,GACb,OAAOkF,WAAWlF,IAAU,CAChC,CAQA,SAASmF,EAAeC,GAEpB,IADA,IAAIC,EAAY,GACP3E,EAAK,EAAGA,EAAK4E,UAAU1F,OAAQc,IACpC2E,EAAU3E,EAAK,GAAK4E,UAAU5E,GAElC,OAAO2E,EAAUE,QAAO,SAAUC,EAAMC,GAEpC,OAAOD,EAAOP,EADFG,EAAO,UAAYK,EAAW,UAE9C,GAAG,EACP,CAkCA,SAASC,EAA0BlB,GAG/B,IAAImB,EAAcnB,EAAOmB,YAAaC,EAAepB,EAAOoB,aAS5D,IAAKD,IAAgBC,EACjB,OAAOb,EAEX,IAAIK,EAASR,EAAYJ,GAAQqB,iBAAiBrB,GAC9CsB,EA3CR,SAAqBV,GAGjB,IAFA,IACIU,EAAW,CAAC,EACPpF,EAAK,EAAGqF,EAFD,CAAC,MAAO,QAAS,SAAU,QAEDrF,EAAKqF,EAAYnG,OAAQc,IAAM,CACrE,IAAI+E,EAAWM,EAAYrF,GACvBV,EAAQoF,EAAO,WAAaK,GAChCK,EAASL,GAAYR,EAAQjF,EACjC,CACA,OAAO8F,CACX,CAkCmBE,CAAYZ,GACvBa,EAAWH,EAASI,KAAOJ,EAASK,MACpCC,EAAUN,EAASO,IAAMP,EAASQ,OAKlCC,EAAQtB,EAAQG,EAAOmB,OAAQC,EAASvB,EAAQG,EAAOoB,QAqB3D,GAlByB,eAArBpB,EAAOqB,YAOHvF,KAAKwF,MAAMH,EAAQN,KAAcN,IACjCY,GAASpB,EAAeC,EAAQ,OAAQ,SAAWa,GAEnD/E,KAAKwF,MAAMF,EAASJ,KAAaR,IACjCY,GAAUrB,EAAeC,EAAQ,MAAO,UAAYgB,KAoDhE,SAA2B5B,GACvB,OAAOA,IAAWI,EAAYJ,GAAQzD,SAAS4F,eACnD,CA/CSC,CAAkBpC,GAAS,CAK5B,IAAIqC,EAAgB3F,KAAKwF,MAAMH,EAAQN,GAAYN,EAC/CmB,EAAiB5F,KAAKwF,MAAMF,EAASJ,GAAWR,EAMpB,IAA5B1E,KAAK6F,IAAIF,KACTN,GAASM,GAEoB,IAA7B3F,KAAK6F,IAAID,KACTN,GAAUM,EAElB,CACA,OAAO9B,EAAec,EAASI,KAAMJ,EAASO,IAAKE,EAAOC,EAC9D,CAOA,IAAIQ,EAGkC,qBAAvBC,mBACA,SAAUzC,GAAU,OAAOA,aAAkBI,EAAYJ,GAAQyC,kBAAoB,EAKzF,SAAUzC,GAAU,OAAQA,aAAkBI,EAAYJ,GAAQ0C,YAC3C,oBAAnB1C,EAAO2C,OAAyB,EAiB/C,SAASC,EAAe5C,GACpB,OAAK3D,EAGDmG,EAAqBxC,GAhH7B,SAA2BA,GACvB,IAAI6C,EAAO7C,EAAO2C,UAClB,OAAOnC,EAAe,EAAG,EAAGqC,EAAKd,MAAOc,EAAKb,OACjD,CA8Gec,CAAkB9C,GAEtBkB,EAA0BlB,GALtBO,CAMf,CAiCA,SAASC,EAAeuC,EAAGC,EAAGjB,EAAOC,GACjC,MAAO,CAAEe,EAAGA,EAAGC,EAAGA,EAAGjB,MAAOA,EAAOC,OAAQA,EAC/C,CAMA,IAAIiB,EAAmC,WAMnC,SAASA,EAAkBjD,GAMvBlF,KAAKoI,eAAiB,EAMtBpI,KAAKqI,gBAAkB,EAMvBrI,KAAKsI,aAAe5C,EAAe,EAAG,EAAG,EAAG,GAC5C1F,KAAKkF,OAASA,CAClB,CAyBA,OAlBAiD,EAAkB/H,UAAUmI,SAAW,WACnC,IAAIC,EAAOV,EAAe9H,KAAKkF,QAE/B,OADAlF,KAAKsI,aAAeE,EACZA,EAAKvB,QAAUjH,KAAKoI,gBACxBI,EAAKtB,SAAWlH,KAAKqI,eAC7B,EAOAF,EAAkB/H,UAAUqI,cAAgB,WACxC,IAAID,EAAOxI,KAAKsI,aAGhB,OAFAtI,KAAKoI,eAAiBI,EAAKvB,MAC3BjH,KAAKqI,gBAAkBG,EAAKtB,OACrBsB,CACX,EACOL,CACX,CApDuC,GAsDnCO,EAOA,SAA6BxD,EAAQyD,GACjC,IAAIC,EA/FZ,SAA4BvH,GACxB,IAAI4G,EAAI5G,EAAG4G,EAAGC,EAAI7G,EAAG6G,EAAGjB,EAAQ5F,EAAG4F,MAAOC,EAAS7F,EAAG6F,OAElD2B,EAAoC,qBAApBC,gBAAkCA,gBAAkB5I,OACpEsI,EAAOtI,OAAO6I,OAAOF,EAAOzI,WAShC,OAPA6E,EAAmBuD,EAAM,CACrBP,EAAGA,EAAGC,EAAGA,EAAGjB,MAAOA,EAAOC,OAAQA,EAClCH,IAAKmB,EACLrB,MAAOoB,EAAIhB,EACXD,OAAQE,EAASgB,EACjBtB,KAAMqB,IAEHO,CACX,CAiF0BQ,CAAmBL,GAOrC1D,EAAmBjF,KAAM,CAAEkF,OAAQA,EAAQ0D,YAAaA,GAC5D,EAIAK,EAAmC,WAWnC,SAASA,EAAkB/H,EAAUgI,EAAYC,GAc7C,GAPAnJ,KAAKoJ,oBAAsB,GAM3BpJ,KAAKqJ,cAAgB,IAAI/J,EACD,oBAAb4B,EACP,MAAM,IAAIoI,UAAU,2DAExBtJ,KAAKuJ,UAAYrI,EACjBlB,KAAKwJ,YAAcN,EACnBlJ,KAAKyJ,aAAeN,CACxB,CAmHA,OA5GAF,EAAkB7I,UAAUkE,QAAU,SAAUY,GAC5C,IAAKc,UAAU1F,OACX,MAAM,IAAIgJ,UAAU,4CAGxB,GAAuB,qBAAZI,SAA6BA,mBAAmBxJ,OAA3D,CAGA,KAAMgF,aAAkBI,EAAYJ,GAAQwE,SACxC,MAAM,IAAIJ,UAAU,yCAExB,IAAIK,EAAe3J,KAAKqJ,cAEpBM,EAAa5I,IAAImE,KAGrByE,EAAalJ,IAAIyE,EAAQ,IAAIiD,EAAkBjD,IAC/ClF,KAAKwJ,YAAYhG,YAAYxD,MAE7BA,KAAKwJ,YAAY1G,UAZjB,CAaJ,EAOAmG,EAAkB7I,UAAUwJ,UAAY,SAAU1E,GAC9C,IAAKc,UAAU1F,OACX,MAAM,IAAIgJ,UAAU,4CAGxB,GAAuB,qBAAZI,SAA6BA,mBAAmBxJ,OAA3D,CAGA,KAAMgF,aAAkBI,EAAYJ,GAAQwE,SACxC,MAAM,IAAIJ,UAAU,yCAExB,IAAIK,EAAe3J,KAAKqJ,cAEnBM,EAAa5I,IAAImE,KAGtByE,EAAa/I,OAAOsE,GACfyE,EAAazD,MACdlG,KAAKwJ,YAAY5F,eAAe5D,MAXpC,CAaJ,EAMAiJ,EAAkB7I,UAAUwE,WAAa,WACrC5E,KAAK6J,cACL7J,KAAKqJ,cAAcrI,QACnBhB,KAAKwJ,YAAY5F,eAAe5D,KACpC,EAOAiJ,EAAkB7I,UAAU8D,aAAe,WACvC,IAAI4F,EAAQ9J,KACZA,KAAK6J,cACL7J,KAAKqJ,cAAcpI,SAAQ,SAAU8I,GAC7BA,EAAYxB,YACZuB,EAAMV,oBAAoBzI,KAAKoJ,EAEvC,GACJ,EAOAd,EAAkB7I,UAAUgE,gBAAkB,WAE1C,GAAKpE,KAAKmE,YAAV,CAGA,IAAIhD,EAAMnB,KAAKyJ,aAEX5I,EAAUb,KAAKoJ,oBAAoBY,KAAI,SAAUD,GACjD,OAAO,IAAIrB,EAAoBqB,EAAY7E,OAAQ6E,EAAYtB,gBACnE,IACAzI,KAAKuJ,UAAUjI,KAAKH,EAAKN,EAASM,GAClCnB,KAAK6J,aAPL,CAQJ,EAMAZ,EAAkB7I,UAAUyJ,YAAc,WACtC7J,KAAKoJ,oBAAoBtI,OAAO,EACpC,EAMAmI,EAAkB7I,UAAU+D,UAAY,WACpC,OAAOnE,KAAKoJ,oBAAoB9I,OAAS,CAC7C,EACO2I,CACX,CAnJuC,GAwJnCpF,EAA+B,qBAAZoG,QAA0B,IAAIA,QAAY,IAAI3K,EAKjE4K,EAOA,SAASA,EAAehJ,GACpB,KAAMlB,gBAAgBkK,GAClB,MAAM,IAAIZ,UAAU,sCAExB,IAAKtD,UAAU1F,OACX,MAAM,IAAIgJ,UAAU,4CAExB,IAAIJ,EAAa1G,EAAyBuC,cACtCtB,EAAW,IAAIwF,EAAkB/H,EAAUgI,EAAYlJ,MAC3D6D,EAAUpD,IAAIT,KAAMyD,EACxB,EAIJ,CACI,UACA,YACA,cACFxC,SAAQ,SAAUkJ,GAChBD,EAAe9J,UAAU+J,GAAU,WAC/B,IAAI9I,EACJ,OAAQA,EAAKwC,EAAUxD,IAAIL,OAAOmK,GAAQC,MAAM/I,EAAI2E,UACxD,CACJ,IAEA,IAAIlG,EAEuC,qBAA5B4B,EAASwI,eACTxI,EAASwI,eAEbA,EAmCLG,EAAkB,SAACC,GACrB,IAAMC,EAAUD,EAAGE,wBACnB,MAAO,CACHvD,MAAOsD,EAAQtD,MACfC,OAAQqD,EAAQrD,OAChBN,KAAM2D,EAAQ3D,KAAOpF,OAAOiJ,QAC5B5D,MAAO0D,EAAQ1D,MAAQrF,OAAOiJ,QAC9BzD,OAAQuD,EAAQvD,OAASxF,OAAOkJ,QAChC3D,IAAKwD,EAAQxD,IAAMvF,OAAOkJ,QAC1BzC,EAAGsC,EAAQtC,EAAIzG,OAAOiJ,QACtBvC,EAAGqC,EAAQrC,EAAI1G,OAAOkJ,QACtBC,QAASnJ,OAAOoJ,iBAExB,EAQMC,EAAgB,WAClB,SAAAA,EAAYC,IAAQC,EAAAA,EAAAA,GAAA,KAAAF,GAChB7K,KAAKgL,QAAU,CAAC,EAChBhL,KAAK8K,OAASA,EACd9K,KAAKiL,cACT,CAwBC,OAvBDC,EAAAA,EAAAA,GAAAL,EAAA,EAAAnL,IAAA,eAAAgB,MAGA,WACIV,KAAKmL,WAAanL,KAAK8K,OAAON,uBAClC,GACA,CAAA9K,IAAA,mBAAAgB,MAGA,SAAiB0K,EAAc5C,GAC3BxI,KAAKgL,QAAQI,GAAgB5C,CACjC,GACA,CAAA9I,IAAA,WAAAgB,MAGA,SAAS0K,GACL,OAAOpL,KAAKgL,QAAQI,GArEN,SAACC,EAAeF,GAClC,IAAMR,EAAUnJ,OAAOoJ,iBACfhE,EAAgCyE,EAAhCzE,KAAMI,EAA0BqE,EAA1BrE,OAAQC,EAAkBoE,EAAlBpE,MAAOC,EAAWmE,EAAXnE,OAKvBoE,EAAoBH,EAAWnE,QAAUA,EAASxF,OAAOkJ,SAM/D,MAAO,CACH9D,MALeA,EAAOuE,EAAWvE,KAAOpF,OAAOiJ,SAAWE,EAM1D3D,OALgBsE,EAAoBX,EAMpC1D,MALeA,EAAQ0D,EAMvBzD,OALgBA,EAASyD,EAOjC,CAkD4CY,CAAcvL,KAAKgL,QAAQI,GAAepL,KAAKmL,iBAAcK,CACrG,GACA,CAAA9L,IAAA,mBAAAgB,MAGA,SAAiB0K,UACNpL,KAAKgL,QAAQI,EACxB,KAACP,CAAA,CA7BiB,GAwChBY,GAAeP,EAAAA,EAAAA,IACjB,SAAAO,IAAc,IAAAC,EAAA,MAAAX,EAAAA,EAAAA,GAAA,KAAAU,GACVzL,KAAK2L,iBAAmB,GACxB3L,KAAK4L,YAAc,CAAC,EACpB5L,KAAK6L,eAAiB,CAAC,EACvB7L,KAAK8L,SAAW,WAEZ,OAAAC,EAAAA,EAAAA,GAAWL,EAAKC,iBACpB,EACA3L,KAAKgM,QAAU,WACXN,EAAKC,iBAAiB1K,SAAQ,SAAAgL,GAAA,IAAGC,EAAED,EAAFC,GAAE,OAAOR,EAAKS,OAAOD,EAAG,GAC7D,EACAlM,KAAKoM,UAAY,SAAAC,GAAsC,IAAnCC,EAAOD,EAAPC,QAASC,EAAQF,EAARE,SAAUC,EAASH,EAATG,UAGnC,GAAiB,MAAbA,EAAJ,CAGA,IAAMC,EAAY,IAAItK,MAAK,IAAIA,MAAOuK,UAAYH,GAC5CI,EAAU,IAAIxK,KACdyK,EAA0C,MAAzBN,EAAQO,cAAwBP,EAAQO,cAAgBP,EAAQJ,GACjFY,EAAYR,EAAQJ,GACpBa,EAAY,EAAIP,EAAUvF,MAASsF,EAGrCO,KAAapB,EAAKG,iBAGtBH,EAAKG,eAAeiB,GAAa,CAC7BD,cAAeP,EAAQO,eAE3BnB,EAAKG,eAAeiB,GAAWE,WAAaC,aAAY,WACpD,IAAMC,EAAW,IAAI/K,KAAKA,KAAKC,MAAQmK,GACjCY,EAAS,IAAIhL,KAEnBuJ,EAAKE,YAAYgB,GAAkB,CAAEQ,MAAOF,EAAUG,IAAKF,GAE3D,IAAMG,EAAeC,QAAQhB,GAC7BD,EAAQkB,eAAe,CACnBJ,MAAOF,EACPG,IAAKF,EACLZ,SAAAA,EACAkB,iCAAkCH,GAE1C,GAAGP,GACHrB,EAAKE,YAAYgB,GAAkB,CAAEQ,MAAOX,EAAWY,IAAKV,GAE5DjB,EAAKgC,kBAAkB,CACnBN,MAAOX,EACPY,IAAKV,EACLL,QAAAA,EACAC,SAAAA,IAlCJ,CAoCJ,EACAvM,KAAK2N,SAAW,SAAAC,GAAgC,IAA7BtB,EAAOsB,EAAPtB,QAASO,EAAae,EAAbf,cACxB,GAAe,MAAXP,GAAoC,MAAjBO,EAAvB,CAGA,IAAMgB,EAAqB,SAACC,GACW,MAA/BpC,EAAKG,eAAeiC,KAExBC,cAAcrC,EAAKG,eAAeiC,GAAQd,mBACnCtB,EAAKG,eAAeiC,GAC/B,EAEqB,MAAjBjB,EACA3M,OAAOW,QAAQ6K,EAAKG,gBACf5H,QAAO,SAAA+J,GAAQ,OAARC,EAAAA,EAAAA,GAAAD,EAAA,GAAQ,GAAWnB,gBAAkBA,CAAa,IACzD5L,SAAQ,SAAAiN,GAAA,IAAEJ,GAAFG,EAAAA,EAAAA,GAAAC,EAAA,GAAQ,UAAML,EAAmBC,EAAO,IAErC,MAAXxB,GAELuB,EAAmBvB,EAAQJ,GAf/B,CAiBJ,EACAlM,KAAKmO,IAAM,SAAAC,GAA0D,IAAvD9B,EAAO8B,EAAP9B,QAASE,EAAS4B,EAAT5B,UAAWD,EAAQ6B,EAAR7B,SAAQ8B,EAAAD,EAAEE,WAAAA,OAAU,IAAAD,GAAOA,EAMzD,GALA3C,EAAKC,iBAAmB,GAAH4C,QAAAxC,EAAAA,EAAAA,GAAOL,EAAKC,kBAAgB,CAAEW,IAK/CA,EAAQO,eAAiBnB,EAAKE,YAAYU,EAAQO,gBAAkByB,EAAY,CAChF,IAAMb,EAAmCF,QAAQhB,GACjDD,EAAQkB,eAAetN,OAAOsO,OAAOtO,OAAOsO,OAAO,CAAC,EAAG9C,EAAKE,YAAYU,EAAQO,gBAAiB,CAAEN,SAAAA,EAC/FkB,iCAAAA,IACR,CAEgB,MAAZlB,GACAb,EAAKU,UAAU,CAAEE,QAAAA,EAASC,SAAAA,EAAUC,UAAAA,GAE5C,EACAxM,KAAKmM,OAAS,SAACsC,GACX,IAAMC,EAAIhD,EAAKC,iBAAiBgD,MAAK,SAAAC,GAAK,OAAAA,EAAF1C,KAAgBuC,CAAS,IAE7DC,GAAKA,EAAE1C,UACPN,EAAKiC,SAAS,CAAErB,QAASoC,IACzBA,EAAE1C,WAGNN,EAAKC,iBAAmBD,EAAKC,iBAAiB1H,QAAO,SAAA4K,GAAK,OAAAA,EAAF3C,KAAgBuC,CAAS,GACrF,EAOAzO,KAAK0N,kBAAoB,SAAAoB,GAAwC,IAArC1B,EAAK0B,EAAL1B,MAAOC,EAAGyB,EAAHzB,IAAKf,EAAOwC,EAAPxC,QAASC,EAAQuC,EAARvC,SACvC7M,EAAM4M,EAAQO,cAAgBP,EAAQO,cAAgBP,EAAQJ,GAEpER,EAAKE,YAAYlM,GAAO,CAAE0N,MAAAA,EAAOC,IAAAA,GACjB,MAAZd,GACAb,EAAKiC,SAAS,CAAErB,QAAAA,EAASO,cAAeP,EAAQO,gBAEpD,IAAMW,EAAiB,SAACkB,GACpB,IAAMpB,EAAeC,QAAQhB,GAC7BmC,EAAElB,eAAe,CAAEJ,MAAAA,EAAOC,IAAAA,EAAKd,SAAAA,EAAUkB,iCAAkCH,GAC/E,EACIhB,EAAQO,cAESnB,EAAKC,iBAAiB1H,QAAO,SAAA8K,GAAA,IAAkBC,EAAKD,EAApBlC,cAAa,OAAcP,EAAQO,gBAAkBmC,CAAK,IAElG/N,QAAQuM,GAOjBA,EAAelB,EAEvB,CACJ,IAIE2C,GAAeC,EAAAA,EAAAA,IAAQ,SAACR,GAAC,OAAiB,MAAZA,EAAES,MAAc,IAyCpD,IAgKMC,EAhKsB,SAACC,GACzB,IAAIrE,EA2BAsE,EACAxE,EACAyE,EACAC,EACEC,EAAuB,WACrBH,IAEAA,EAASI,gBAAe,GAGxBJ,EAASK,cAAc,SAAU,GACjCL,EAAStO,QACTsO,EAASI,gBAAe,GAEJL,EAAgBvD,WAAW7H,OAAOgL,GAC1ChO,QAAQ2O,GAE5B,EACMC,EAAW,WACb,GAAIP,GAAYxE,EAAQ,CACpB,IAAI7C,EAAI,EACJC,EAAI,EACR,IAAKqH,EACD,OACA,YAAaA,GACbtH,EAAIsH,EAAU9E,QACdvC,EAAIqH,EAAU7E,UAGdzC,EAAIsH,EAAUO,WACd5H,EAAIqH,EAAUQ,WAElB,IAAMC,EAAY,aAAHzB,OAAgBtG,EAAC,QAAAsG,OAAOrG,EAAC,OAExCoH,EAASW,WAAWC,MAAMF,UAAYA,EACtChF,EAAQC,eACRwE,GACJ,CACJ,EACMU,EAAW,WACbC,IACId,GAAYxE,KAzFxB,SAAqCwE,GACjC,IAAMxE,EAASwE,EAASW,WAClBhJ,EAAQrF,KAAKyO,MAAMvF,EAAOzE,YAAc7E,OAAOoJ,mBAAqB,EACpE1D,EAAStF,KAAKyO,MAAMvF,EAAOxE,aAAe9E,OAAOoJ,mBAAqB,EACtE0F,EAAaxF,EAAO7D,QAAUA,GAAS6D,EAAO5D,SAAWA,EAC3DoJ,GACAhB,EAASiB,QAAQtJ,EAAOC,GAAQ,EAGxC,CAiFYsJ,CAA4BlB,GAC5BtE,EAAQC,eACRwE,IAER,EA6BMW,EAAoB,WACtB,GAAe,MAAXpF,EACA,MAAM,IAAIyF,MAAM,kKAGxB,EACMb,EAAS,SAACc,GACZN,IACA,IAAM7E,EAAgBP,EAAQ2F,SAASD,EAAWxE,IAC9CoD,GAAYxE,GAAUS,GA9IT,SAAC+D,EAAQsB,EAAAC,GAAyD,IAArDC,EAAKF,EAALE,MAAO3B,EAAMyB,EAANzB,OAAYvI,EAAIiK,EAAJjK,KAAMI,EAAM6J,EAAN7J,OAAQC,EAAK4J,EAAL5J,MAAOC,EAAM2J,EAAN3J,OAC1EoI,EAASyB,WAAWnK,EAAMI,EAAQC,EAAOC,GACzCoI,EAAS0B,YAAYpK,EAAMI,EAAQC,EAAOC,GAC1CoI,EAASM,OAAOkB,EAAO3B,EAC3B,CA2IY8B,CAAiB3B,EAAUoB,EAAYnF,EAE/C,EA8BA,MAAO,CACH2F,cAvEkB,SAACC,GAAoE,IAAtDC,EAAuBpL,UAAA1F,OAAA,QAAAkL,IAAAxF,UAAA,GAAAA,UAAA,GAAG,WAAQ,EAAGqL,EAAYrL,UAAA1F,OAAA,EAAA0F,UAAA,QAAAwF,EAClFR,EAAU,IAAIH,EAAiBsG,GAC/BrG,EAASqG,EACT7B,EAAW,IAAIgC,EAAAA,EAAc,CAAExG,OAAAA,EAAQyG,OAAO,EAAMC,WAAW,EAAMC,uBAAuB,IAC5FlC,EAAY8B,GAAgB7P,OAC5B4P,EAAwB9B,EAASoC,cAIjCpC,EAASI,gBAAe,GACxBJ,EAASK,cAAc,EAAU,GACjCE,IACAM,IAEAZ,EAAUlL,iBAAiB,SAAUwL,GACjCN,aAAqB7F,SACrB8F,EAAwB,IAAI1P,EAAMqQ,IACZ7L,QAAQiL,GAG9BA,EAAUlL,iBAAiB,SAAU8L,EAE7C,EAkDInE,QA/BY,WACRsD,GACAA,EAAStD,UAEbqD,EAAgBrD,UAEZuD,IACAA,EAAU5K,oBAAoB,SAAUkL,GACxCN,EAAU5K,oBAAoB,SAAUwL,IAExCX,GACAA,EAAsB5K,YAE9B,EAmBIgL,OAAAA,EACA+B,cA1IkB,SAAHC,GAAA,IAAMtF,EAAOsF,EAAPtF,QAASE,EAASoF,EAATpF,UAAWD,EAAQqF,EAARrF,SAAQsF,EAAAD,EAAEtD,WAAAA,OAAU,IAAAuD,GAAOA,EAAA,OAAQxC,EAAgBlB,IAAI,CAAE7B,QAAAA,EAASE,UAAAA,EAAWD,SAAAA,EAAU+B,WAAAA,GAAa,EA2I7IwD,iBArIqB,SAAC1G,GACtBgF,IACAf,EAAgBlD,OAAOf,GACvBJ,EAAQ8G,iBAAiB1G,GACzBqE,GACJ,EAiIIsC,aAjBiB,SAACC,EAASxJ,GAC3B4H,IACApF,EAAQiH,iBAAiBD,EAASxJ,GAClCiH,GACJ,EAcIyC,gBAAiB7C,EAAgB3B,kBACjCtB,UAAWiD,EAAgBjD,UAC3BuB,SAAU0B,EAAgB1B,SAC1BwE,mBAbuB,WACvBhC,GACJ,EAaJ,CAGsBiC,CAAoB,IAAI3G,E","sources":["../node_modules/@iot-app-kit/components/dist/esm/webglContext-6c9fd90d.js"],"sourcesContent":["import { W as WebGLRenderer } from './three.module-8c8bcb27.js';\nimport { i as isValid } from './predicates-248e16b2.js';\n\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/**\n * Convert a rect to a ClipSpaceRect\n *\n * This will return us the coordinates of a rectangle within clip space coordinates (i.e. coordinate space for webGL)\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection to learn more about clip space\n */\nconst clipSpaceRect = (containerRect, canvasRect) => {\n    const density = window.devicePixelRatio;\n    const { left, bottom, width, height } = containerRect;\n    // The coordinate y-axis is flipped between the DOM and webGL so we must correct for that.\n    // Bounding client rect measures the bottom as the distance from the top, i.e.:\n    // For DOM, (0, 0) is the top left.\n    // In WebGL, (0, 0) is the bottom left.\n    const positiveYUpBottom = canvasRect.bottom - (bottom - window.scrollY);\n    // Need to account for pixel density - i.e. retina display\n    const pixelLeft = (left - canvasRect.left - window.scrollX) * density;\n    const pixelBottom = positiveYUpBottom * density;\n    const pixelWidth = width * density;\n    const pixelHeight = height * density;\n    return {\n        left: pixelLeft,\n        bottom: pixelBottom,\n        width: pixelWidth,\n        height: pixelHeight,\n    };\n};\n/**\n * Return a rect with the property of being unchanged upon scrolling.\n *\n * The reason this is desirable is because it allows us to not have to re-calculate all our\n * rect's every time a scroll event occurs. This allows for a smooth scroll to occur.\n */\nconst rectScrollFixed = (el) => {\n    const domRect = el.getBoundingClientRect();\n    return {\n        width: domRect.width,\n        height: domRect.height,\n        left: domRect.left + window.scrollX,\n        right: domRect.right + window.scrollX,\n        bottom: domRect.bottom + window.scrollY,\n        top: domRect.top + window.scrollY,\n        x: domRect.x + window.scrollX,\n        y: domRect.y + window.scrollY,\n        density: window.devicePixelRatio,\n    };\n};\n/**\n * A map of clip-space rectangles for chart scenes.\n *\n * Allows us to track what region in clip-space each chart scene should be rendered in.\n * The goal is to not have to continually make calls to `getBoundingClientRect` since it is an expsensive operation\n * which causes layouts to be re-calculated: http://dcousineau.com/blog/2013/09/03/high-performance-js-tip/\n */\nclass ClipSpaceRectMap {\n    constructor(canvas) {\n        this.rectMap = {};\n        this.canvas = canvas;\n        this.updateCanvas();\n    }\n    /**\n     * Update DOMRect for canvas\n     */\n    updateCanvas() {\n        this.canvasRect = this.canvas.getBoundingClientRect();\n    }\n    /**\n     * Updates the rect for the requested chart scene\n     */\n    updateChartScene(chartSceneId, rect) {\n        this.rectMap[chartSceneId] = rect;\n    }\n    /**\n     * Return clip rect for the requested chart scene\n     */\n    clipRect(chartSceneId) {\n        return this.rectMap[chartSceneId] ? clipSpaceRect(this.rectMap[chartSceneId], this.canvasRect) : undefined;\n    }\n    /**\n     * Remove chart scene from rect map\n     */\n    removeChartScene(chartSceneId) {\n        delete this.rectMap[chartSceneId];\n    }\n}\n\n/**\n * Handlers the syncing view port across different view port groups.\n *\n * This allows us to have defined groupings of widgets which all efficiently have their viewports synced\n * without utilizing any framework level code.\n *\n * This allows us to have performant syncing of charts.\n */\nclass ViewportHandler {\n    constructor() {\n        this.viewportManagers = [];\n        this.viewportMap = {};\n        this.viewportLiveId = {};\n        this.managers = () => {\n            // NOTE: Providing new reference to a array to prevent manipulation of the internal array from the outside.\n            return [...this.viewportManagers];\n        };\n        this.dispose = () => {\n            this.viewportManagers.forEach(({ id }) => this.remove(id));\n        };\n        this.startTick = ({ manager, duration, chartSize }) => {\n            // If chart size is null then it is KPI or Status Grid\n            // We do not have to tick for those.\n            if (chartSize == null) {\n                return;\n            }\n            const initStart = new Date(new Date().getTime() - duration);\n            const initEnd = new Date();\n            const viewPortMapKey = manager.viewportGroup != null ? manager.viewportGroup : manager.id;\n            const liveIdKey = manager.id;\n            const tickRate = (1 / chartSize.width) * duration;\n            // If we are adding a chart into an existing group\n            // we do nothing because we have one clock for the whole group\n            if (liveIdKey in this.viewportLiveId) {\n                return;\n            }\n            this.viewportLiveId[liveIdKey] = {\n                viewportGroup: manager.viewportGroup,\n            };\n            this.viewportLiveId[liveIdKey].intervalId = setInterval(() => {\n                const newStart = new Date(Date.now() - duration);\n                const newEnd = new Date();\n                // Sets the new start and end in the viewport live id for the current manager\n                this.viewportMap[viewPortMapKey] = { start: newStart, end: newEnd };\n                // Have manager update its own viewport, preventing 'dateRangeChange' events when in live mode\n                const isInLiveMode = Boolean(duration);\n                manager.updateViewPort({\n                    start: newStart,\n                    end: newEnd,\n                    duration,\n                    shouldBlockDateRangeChangedEvent: isInLiveMode,\n                });\n            }, tickRate);\n            this.viewportMap[viewPortMapKey] = { start: initStart, end: initEnd };\n            // Sync the chart to the new viewport so we dont need to delay the sync by wait for the interval tick\n            this.syncViewPortGroup({\n                start: initStart,\n                end: initEnd,\n                manager,\n                duration,\n            });\n        };\n        this.stopTick = ({ manager, viewportGroup }) => {\n            if (manager == null && viewportGroup == null) {\n                return;\n            }\n            const clearInternalClock = (liveId) => {\n                if (this.viewportLiveId[liveId] == null)\n                    return;\n                clearInterval(this.viewportLiveId[liveId].intervalId);\n                delete this.viewportLiveId[liveId];\n            };\n            // Clear the internal clock for all viewports in a group\n            if (viewportGroup != null) {\n                Object.entries(this.viewportLiveId)\n                    .filter(([, item]) => item.viewportGroup === viewportGroup)\n                    .forEach(([liveId]) => clearInternalClock(liveId));\n            }\n            else if (manager != null) {\n                // Clears an internal clock for a single viewport\n                clearInternalClock(manager.id);\n            }\n        };\n        this.add = ({ manager, chartSize, duration, shouldSync = true, }) => {\n            this.viewportManagers = [...this.viewportManagers, manager];\n            /**\n             * If the added chart scene is part of a view port group, sync it's viewport to\n             * the current viewport groups time span.\n             */\n            if (manager.viewportGroup && this.viewportMap[manager.viewportGroup] && shouldSync) {\n                const shouldBlockDateRangeChangedEvent = Boolean(duration);\n                manager.updateViewPort(Object.assign(Object.assign({}, this.viewportMap[manager.viewportGroup]), { duration,\n                    shouldBlockDateRangeChangedEvent }));\n            }\n            // If duration is not null, this means that we want to have live mode\n            if (duration != null) {\n                this.startTick({ manager, duration, chartSize });\n            }\n        };\n        this.remove = (managerId) => {\n            const v = this.viewportManagers.find(({ id }) => id === managerId);\n            // Dispose of the chart scene to ensure that the memory is released\n            if (v && v.dispose) {\n                this.stopTick({ manager: v });\n                v.dispose();\n            }\n            // Remove manager from list of registered view port managers\n            this.viewportManagers = this.viewportManagers.filter(({ id }) => id !== managerId);\n        };\n        /**\n         * Sync all viewports sharing the group of the given chart scene, to have their viewport being at `start`,\n         * and ending at `end`.\n         *\n         * manager - the manager which is the source of this syncing\n         */\n        this.syncViewPortGroup = ({ start, end, manager, duration, }) => {\n            const key = manager.viewportGroup ? manager.viewportGroup : manager.id;\n            // Either you are in a group or you are a single chart\n            this.viewportMap[key] = { start, end };\n            if (duration == null) {\n                this.stopTick({ manager, viewportGroup: manager.viewportGroup });\n            }\n            const updateViewPort = (v) => {\n                const isInLiveMode = Boolean(duration);\n                v.updateViewPort({ start, end, duration, shouldBlockDateRangeChangedEvent: isInLiveMode });\n            };\n            if (manager.viewportGroup) {\n                /** Get all of the groups which belong within the viewport group */\n                const managers = this.viewportManagers.filter(({ viewportGroup: group }) => manager.viewportGroup === group);\n                /**  Sync all of the chart scenes within the viewport group. */\n                managers.forEach(updateViewPort);\n            }\n            else {\n                /**\n                 * No view port group defined, so only update the camera associated with the\n                 * scene which emitted the event (no syncing of other charts.)\n                 */\n                updateViewPort(manager);\n            }\n        };\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst isChartScene = isValid((v) => v.camera != null);\n/**\n * Render Scene Info\n *\n * Renders a single chart scene, which will represent a single, rectangular view of data\n * within the shared WebGL context.\n *\n * This technique is inspired by https://threejsfundamentals.org/threejs/lessons/threejs-multiple-scenes.html\n * In summary, each chart scene has an HTML element  - and the associated scene is rendered to overlay on the\n * rectangle defined by the given HTML element.\n */\nconst renderChartScene = (renderer, { scene, camera }, { left, bottom, width, height }) => {\n    renderer.setScissor(left, bottom, width, height);\n    renderer.setViewport(left, bottom, width, height);\n    renderer.render(scene, camera);\n};\n/**\n * Set the renderer to the size of the screen, adjust for resolution.\n *\n * Needs to be called every time the display size, or resolution changes.\n */\nfunction resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n    const width = Math.floor(canvas.clientWidth * window.devicePixelRatio) || 0;\n    const height = Math.floor(canvas.clientHeight * window.devicePixelRatio) || 0;\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n        renderer.setSize(width, height, false);\n    }\n    return needResize;\n}\n/**\n * Create a webGL renderer\n *\n * Creates a single webGL rendering context which can be shared across different visualizations.\n * The primary motivator for sharing a single WebGL context is due to the overhead and limitations on making multiple WebGL Context.\n * Resources such as buffered data and textures cannot be shared across WebGL Contexts, and furthermore, due to performance considerations\n * of have many WebGL Contexts, certain browsers have a hard limit on the number of active WebGL Contexts.\n *\n * Refer to https://stackoverflow.com/questions/59140439/allowing-more-webgl-contexts for additional context.\n */\nconst createWebGLRenderer = (viewportHandler) => {\n    let rectMap;\n    /**\n     * Add Chart Scene\n     *\n     * Adds a chart scene to be rendered within the webGL context.\n     * Once added, the given `ChartScene` will be part of the animation loop until explicitly removed.\n     *\n     * shouldSync - determines whether the new scene should sync to the existing view port, or if it\n     *                     should instead use the viewport provided with the chart\n     */\n    const addChartScene = ({ manager, chartSize, duration, shouldSync = true, }) => viewportHandler.add({ manager, chartSize, duration, shouldSync });\n    /**\n     * Remove Chart Scene\n     *\n     * Remove and dispose of a given scene.\n     */\n    const removeChartScene = (chartSceneId) => {\n        mustBeInitialized();\n        viewportHandler.remove(chartSceneId);\n        rectMap.removeChartScene(chartSceneId);\n        fullClearAndRerender();\n    };\n    /**\n     * Initiate Rendering Loop\n     *\n     * Begins a rendering loop to render all chart streams onto the provided canvas\n     */\n    let renderer;\n    let canvas;\n    let viewFrame;\n    let viewFrameSizeObserver;\n    const fullClearAndRerender = () => {\n        if (renderer) {\n            // Turn off scissor test to make the clear effect the entire canvas\n            renderer.setScissorTest(false);\n            // Important to set the clear color again, since the webGL context may have been lost, causing\n            // the clear color to be reset to the default.\n            renderer.setClearColor(0xffffff, 0);\n            renderer.clear();\n            renderer.setScissorTest(true);\n            // Re-render every chart scene. Necessary since entire canvas has been cleared\n            const chartScenes = viewportHandler.managers().filter(isChartScene);\n            chartScenes.forEach(render);\n        }\n    };\n    const onScroll = () => {\n        if (renderer && canvas) {\n            let x = 0;\n            let y = 0;\n            if (!viewFrame)\n                return;\n            if ('scrollX' in viewFrame) {\n                x = viewFrame.scrollX;\n                y = viewFrame.scrollY;\n            }\n            else {\n                x = viewFrame.scrollLeft;\n                y = viewFrame.scrollTop;\n            }\n            const transform = `translate(${x}px, ${y}px)`;\n            // eslint-disable-next-line no-param-reassign\n            renderer.domElement.style.transform = transform;\n            rectMap.updateCanvas();\n            fullClearAndRerender();\n        }\n    };\n    const onResize = () => {\n        mustBeInitialized();\n        if (renderer && canvas) {\n            resizeRendererToDisplaySize(renderer);\n            rectMap.updateCanvas();\n            fullClearAndRerender();\n        }\n    };\n    const initRendering = (renderCanvas, onContextInitialization = () => { }, viewFrameRef) => {\n        rectMap = new ClipSpaceRectMap(renderCanvas);\n        canvas = renderCanvas;\n        renderer = new WebGLRenderer({ canvas, alpha: true, antialias: true, preserveDrawingBuffer: true });\n        viewFrame = viewFrameRef || window;\n        onContextInitialization(renderer.getContext());\n        // Enable scissor test, which allows us to render our visualizations to a subset of the canvas\n        // https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setScissor\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\n        renderer.setScissorTest(true);\n        renderer.setClearColor(0x000000, 0); // transparent clear\n        onScroll();\n        onResize();\n        // setup viewframe size and scroll events\n        viewFrame.addEventListener('scroll', onScroll);\n        if (viewFrame instanceof Element) {\n            viewFrameSizeObserver = new index(onResize);\n            viewFrameSizeObserver.observe(viewFrame);\n        }\n        else {\n            viewFrame.addEventListener('resize', onResize);\n        }\n    };\n    /**\n     * Enforces that the webgl context must first be initialized.\n     *\n     * Throws an error when the initialized has failed to occur.\n     */\n    const mustBeInitialized = () => {\n        if (rectMap == null) {\n            throw new Error('webgl context must be initialized before it can be utilized. ' +\n                'Please refer to https://synchrocharts.com/#/Setup to learn more about how to setup Synchro Charts.');\n        }\n    };\n    const render = (chartScene) => {\n        mustBeInitialized();\n        const clipSpaceRect = rectMap.clipRect(chartScene.id);\n        if (renderer && canvas && clipSpaceRect) {\n            renderChartScene(renderer, chartScene, clipSpaceRect);\n        }\n    };\n    const dispose = () => {\n        if (renderer) {\n            renderer.dispose();\n        }\n        viewportHandler.dispose();\n        /** Release event listeners */\n        if (viewFrame) {\n            viewFrame.removeEventListener('scroll', onScroll);\n            viewFrame.removeEventListener('resize', onResize);\n        }\n        if (viewFrameSizeObserver) {\n            viewFrameSizeObserver.disconnect();\n        }\n    };\n    /**\n     * Registers the position and dimension of where the requested chart scene renders to.\n     * Clears the previous renderer location if it exists.\n     */\n    const setChartRect = (sceneId, rect) => {\n        mustBeInitialized();\n        rectMap.updateChartScene(sceneId, rect);\n        fullClearAndRerender();\n    };\n    /**\n     * This must be called every time resolution has changed.\n     */\n    const onResolutionChange = () => {\n        onResize();\n    };\n    return {\n        initRendering,\n        dispose,\n        render,\n        addChartScene,\n        removeChartScene,\n        setChartRect,\n        updateViewPorts: viewportHandler.syncViewPortGroup,\n        startTick: viewportHandler.startTick,\n        stopTick: viewportHandler.stopTick,\n        onResolutionChange,\n    };\n};\n// TODO: Rather than exposing this as a singleton, it would be preferred to expose it as\n//  a shared context within a component sub-tree.\nconst webGLRenderer = createWebGLRenderer(new ViewportHandler());\n\nexport { index as i, rectScrollFixed as r, webGLRenderer as w };\n"],"names":["MapShim","Map","getIndex","arr","key","result","some","entry","index","class_1","this","__entries__","Object","defineProperty","prototype","get","length","enumerable","configurable","set","value","push","delete","entries","splice","has","clear","forEach","callback","ctx","_i","_a","call","isBrowser","window","document","global$1","global","Math","self","Function","requestAnimationFrame$1","requestAnimationFrame","bind","setTimeout","Date","now","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","delay","leadingCall","trailingCall","lastCallTime","resolvePending","proxy","timeoutCallback","timeStamp","throttle","addObserver","observer","indexOf","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","filter","gatherActive","hasActive","broadcastActive","addEventListener","observe","attributes","childList","characterData","subtree","removeEventListener","disconnect","_b","propertyName","getInstance","instance_","defineConfigurable","target","props","keys","writable","getWindowOf","ownerDocument","defaultView","emptyRect","createRectInit","toFloat","parseFloat","getBordersSize","styles","positions","arguments","reduce","size","position","getHTMLElementContentRect","clientWidth","clientHeight","getComputedStyle","paddings","positions_1","getPaddings","horizPad","left","right","vertPad","top","bottom","width","height","boxSizing","round","documentElement","isDocumentElement","vertScrollbar","horizScrollbar","abs","isSVGGraphicsElement","SVGGraphicsElement","SVGElement","getBBox","getContentRect","bbox","getSVGContentRect","x","y","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","rect","broadcastRect","ResizeObserverEntry","rectInit","contentRect","Constr","DOMRectReadOnly","create","createReadOnlyRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","TypeError","callback_","controller_","callbackCtx_","Element","observations","unobserve","clearActive","_this","observation","map","WeakMap","ResizeObserver","method","apply","rectScrollFixed","el","domRect","getBoundingClientRect","scrollX","scrollY","density","devicePixelRatio","ClipSpaceRectMap","canvas","_classCallCheck","rectMap","updateCanvas","_createClass","canvasRect","chartSceneId","containerRect","positiveYUpBottom","clipSpaceRect","undefined","ViewportHandler","_this2","viewportManagers","viewportMap","viewportLiveId","managers","_toConsumableArray","dispose","_ref","id","remove","startTick","_ref2","manager","duration","chartSize","initStart","getTime","initEnd","viewPortMapKey","viewportGroup","liveIdKey","tickRate","intervalId","setInterval","newStart","newEnd","start","end","isInLiveMode","Boolean","updateViewPort","shouldBlockDateRangeChangedEvent","syncViewPortGroup","stopTick","_ref3","clearInternalClock","liveId","clearInterval","_ref4","_slicedToArray","_ref6","add","_ref8","_ref8$shouldSync","shouldSync","concat","assign","managerId","v","find","_ref9","_ref10","_ref11","_ref12","group","isChartScene","isValid","camera","webGLRenderer","viewportHandler","renderer","viewFrame","viewFrameSizeObserver","fullClearAndRerender","setScissorTest","setClearColor","render","onScroll","scrollLeft","scrollTop","transform","domElement","style","onResize","mustBeInitialized","floor","needResize","setSize","resizeRendererToDisplaySize","Error","chartScene","clipRect","_ref13","_ref14","scene","setScissor","setViewport","renderChartScene","initRendering","renderCanvas","onContextInitialization","viewFrameRef","WebGLRenderer","alpha","antialias","preserveDrawingBuffer","getContext","addChartScene","_ref15","_ref15$shouldSync","removeChartScene","setChartRect","sceneId","updateChartScene","updateViewPorts","onResolutionChange","createWebGLRenderer"],"sourceRoot":""}