{"version":3,"file":"static/js/4585.7ada2b9e.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/chartScene-8136d831.js","../node_modules/@iot-app-kit/components/dist/esm/common-a2d0f0fb.js","../node_modules/@iot-app-kit/components/dist/esm/pointMesh-7ba3f14f.js"],"sourcesContent":["import { I as InstancedBufferGeometry, R as RawShaderMaterial, D as DoubleSide, a as InstancedMesh, B as BufferAttribute, b as InstancedBufferAttribute, S as Scene } from './three.module-8c8bcb27.js';\nimport { M as MAX_THRESHOLD_BANDS, t as thresholdBands, P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS$1, u as updatePointMesh } from './pointMesh-7ba3f14f.js';\nimport { n as numDataPoints, v as vertices, c as constructChartScene, a as clipSpaceConversion, b as needsNewClipSpace } from './clipSpaceConversion-9fa25666.js';\nimport { S as STROKE_WIDTH } from './common-a2d0f0fb.js';\nimport { b as isNumberDataStream } from './predicates-248e16b2.js';\nimport { a as getNumberThresholds } from './utils-0919edc8.js';\n\nconst lineVert = (showColor) => `\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nuniform float xPixelDensity;\nuniform float yPixelDensity;\nattribute vec2 currPoint;\nattribute vec2 nextPoint;\nattribute vec2 position;\nattribute vec3 segmentColor;\nvarying vec3 vColor;\n${showColor ? 'varying float yPositionPx;' : ''}\n\n// line shader using instanced lines\n// https://wwwtyro.net/2019/11/18/instanced-lines.html for information on this approach\nvoid main() {\n  // Convert the points to pixel coordinates - otherwise out basis vectors won't be perpendicular when\n  // rasterized to the screen.\n  vec2 currPointPx = vec2(currPoint.x / xPixelDensity, currPoint.y / yPixelDensity);\n  vec2 nextPointPx = vec2(nextPoint.x / xPixelDensity, nextPoint.y / yPixelDensity);\n\n  // create the basis vectors of a coordinate space where the x axis is parallel with\n  // the path between currPoint and nextPoint, and the y axis is perpendicular to the\n  // path between currPoint and nextPoint\n  vec2 xBasis = nextPointPx - currPointPx;\n  vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\n\n  // project the instance segment along the basis vectors\n  vec2 positionPx = currPointPx + xBasis * position.x + yBasis * width * position.y;\n\n  // Convert from pixel coordinates back to model space\n  vec2 positionModel = vec2(positionPx.x * xPixelDensity, positionPx.y * yPixelDensity);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(positionModel, 0.0, 1.0);\n  vColor = segmentColor;\n  ${showColor ? 'yPositionPx = positionPx.y;' : ''}\n}\n`;\n\nconst lineFrag = `\nprecision highp float;\nvarying vec3 vColor;\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n`;\n\nconst lineColorationFrag = `\n// This file is only being used when we have threshold bands\n// that will break the line segments into different color\n#define MAX_NUM_TOTAL_THRESHOLD_BAND ${MAX_THRESHOLD_BANDS}\n\nprecision highp float;\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float yPositionPx;\nuniform float yPixelDensity;\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\n\n// Fills in triangles which make up a line segment, with the corresponding color\nvoid main() {\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = yPositionPx > thresholdBands[i].lower / yPixelDensity\n      && yPositionPx < thresholdBands[i].upper / yPixelDensity;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = yPositionPx == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color / 255.0, 1.0);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, 1.0);\n    }\n  }\n}\n`;\n\n/**\n * Get Pixel Density in terms of the clip space\n *\n * Returns the ratio of model space to pixel space in each dimension.\n * i.e. how many pixels does 10 minutes represent on a given `container`?\n */\nconst pixelDensity = ({ viewport: { end, start, yMax, yMin }, toClipSpace, size, }) => {\n    const { width, height } = size;\n    // We must translate our viewport to be in terms of the coordinate system which matches\n    // that of the data being passed in - since we want to know how many pixels\n    // are represented within the webGL context. i.e. clip space pixel density.\n    const x = Math.abs((toClipSpace(end.getTime()) - toClipSpace(start.getTime())) / width);\n    const y = Math.abs((yMax - yMin) / height);\n    return { x, y };\n};\n\n/* eslint-disable no-param-reassign */\n/**\n * Create Line Mesh`\n *\n * The representation of the lines between points on a chart.\n */\n// Ensure that the line width is equal to the existing <sc-line-chart />'s line thickness\nconst LINE_WIDTH = STROKE_WIDTH;\nconst LINE_MESH_INDEX = 1;\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nconst NUM_POSITION_COMPONENTS = 2; // (x, y)\nconst NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nconst numLineSegments = (streamVertexSets) => {\n    const segments = streamVertexSets.reduce((totalSegments, streamVertexSet) => {\n        // For every point added within a stream, a new segment is drawn,\n        // While there is no visible line segment for the first point added in a stream,\n        // it draws a 'degenerate' segment which is rendered as nothing.\n        // This is purely an implementation detail of the shader, but we must take it into account\n        // when determining the number of 'instances' to be drawn by the instance mesh.\n        // ex1. o--o--o--o  [4 points, 3 visible segments, 1 degenerate segment]\n        // ex2. o           [1 point, 0 visible segments]\n        const streamSegments = Math.max(streamVertexSet.length, 0);\n        return totalSegments + streamSegments;\n    }, 0);\n    return segments;\n};\nconst updateMesh = (dataStreams, mesh, toClipSpace) => {\n    const streamVertexSets = dataStreams.filter(isNumberDataStream).map(stream => vertices(stream, stream.resolution));\n    // Set the number of instances of the line segment that are to be rendered.\n    mesh.count = numLineSegments(streamVertexSets);\n    const { geometry } = mesh;\n    /**\n     * Fill Buffers with data\n     */\n    const { currPoint, nextPoint, segmentColor } = geometry.attributes;\n    let positionIndex = 0;\n    let colorIndex = 0;\n    streamVertexSets.forEach(streamVertexSet => {\n        streamVertexSet.forEach((currVertex, vertexNum) => {\n            const isLastVertex = vertexNum === streamVertexSet.length - 1;\n            const nextVertex = !isLastVertex ? streamVertexSet[vertexNum + 1] : currVertex;\n            const [currX, currY, r, g, b] = currVertex;\n            const [nextX, nextY] = nextVertex;\n            // NOTE: WebGL takes a buffer of values and then converts those to vectors or the correct dimensionality\n            // Set Current Position (currX, currY)\n            currPoint.array[positionIndex] = toClipSpace(currX);\n            currPoint.array[positionIndex + 1] = currY;\n            // Set Next Position (nextX, nextY)\n            nextPoint.array[positionIndex] = toClipSpace(nextX);\n            nextPoint.array[positionIndex + 1] = nextY;\n            // Set Line Segment Color (r, g, b)\n            segmentColor.array[colorIndex] = r;\n            segmentColor.array[colorIndex + 1] = g;\n            segmentColor.array[colorIndex + 2] = b;\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            positionIndex += NUM_POSITION_COMPONENTS;\n        });\n    });\n    currPoint.needsUpdate = true;\n    nextPoint.needsUpdate = true;\n    segmentColor.needsUpdate = true;\n};\n/**\n * Segment Instance Geometry is a square made up of two triangles,\n * as shown in the 'perfect' diagram shown below:\n * (0, 0.5)----(1, 0.5)\n *    |  \\         |\n *    |     \\      |\n *    |         \\  |\n * (0, -0.5)---(1, -0.5)\n */\nconst segmentInstanceGeometry = [\n    [0, -0.5],\n    [1, -0.5],\n    [1, 0.5],\n    [0, -0.5],\n    [1, 0.5],\n    [0, 0.5],\n];\nconst initializeGeometry = (geometry, bufferSize) => {\n    /**\n     * Create Attributes\n     */\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(segmentInstanceGeometry.flat()), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('currPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('nextPoint', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('segmentColor', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nconst lineMesh = ({ viewport, dataStreams, chartSize, minBufferSize, bufferFactor, toClipSpace, thresholdOptions, thresholds, }) => {\n    const geometry = new InstancedBufferGeometry();\n    const bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(geometry, bufferSize);\n    // Construct shader\n    const { x: xPixelDensity, y: yPixelDensity } = pixelDensity({ viewport, toClipSpace, size: chartSize });\n    const { showColor = true } = thresholdOptions;\n    const lineMaterial = new RawShaderMaterial({\n        vertexShader: lineVert(showColor && thresholds.length > 0),\n        fragmentShader: !showColor || thresholds.length === 0 ? lineFrag : lineColorationFrag,\n        side: DoubleSide,\n        transparent: true,\n        uniforms: {\n            width: {\n                value: LINE_WIDTH,\n            },\n            xPixelDensity: {\n                value: xPixelDensity,\n            },\n            yPixelDensity: {\n                value: yPixelDensity,\n            },\n            thresholdBands: {\n                value: thresholdBands(thresholds),\n            },\n        },\n    });\n    const mesh = new InstancedMesh(geometry, lineMaterial, bufferSize);\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    updateMesh(dataStreams, mesh, toClipSpace);\n    return mesh;\n};\nconst updateLineMesh = ({ chartSize, toClipSpace, lines, dataStreams, viewport, hasDataChanged, }) => {\n    /**\n     * Update Uniforms\n     */\n    const { x: xPixelDensity, y: yPixelDensity } = pixelDensity({ viewport, toClipSpace, size: chartSize });\n    lines.material.uniforms.xPixelDensity.value = xPixelDensity;\n    lines.material.uniforms.yPixelDensity.value = yPixelDensity;\n    /**\n     * Update Data\n     */\n    if (hasDataChanged) {\n        updateMesh(dataStreams, lines, toClipSpace);\n    }\n};\n\nconst chartScene = ({ dataStreams, chartSize, container, viewport, minBufferSize, bufferFactor, onUpdate, thresholdOptions, thresholds, }) => {\n    const scene = new Scene();\n    const toClipSpace = clipSpaceConversion(viewport);\n    const numberThresholds = getNumberThresholds(thresholds);\n    // Create and add meshes to the chart scene\n    const meshList = [];\n    meshList[LINE_MESH_INDEX] = lineMesh({\n        toClipSpace,\n        chartSize,\n        dataStreams,\n        viewport,\n        minBufferSize,\n        bufferFactor,\n        thresholdOptions,\n        thresholds: numberThresholds,\n    });\n    meshList[POINT_MESH_INDEX] = pointMesh({\n        dataStreams,\n        minBufferSize,\n        bufferFactor,\n        toClipSpace,\n        thresholdOptions,\n        thresholds: numberThresholds,\n    });\n    meshList.forEach(mesh => scene.add(mesh));\n    return constructChartScene({ scene, viewport, container, toClipSpace, onUpdate });\n};\nconst maxDataPointsRendered = (points) => points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS$1;\nconst updateChartScene = ({ scene, dataStreams, chartSize, container, viewport, hasDataChanged, bufferFactor, minBufferSize, onUpdate, thresholdOptions, hasAnnotationChanged, thresholds, }) => {\n    const lines = scene.scene.children[LINE_MESH_INDEX];\n    const points = scene.scene.children[POINT_MESH_INDEX];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    const isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace) || hasAnnotationChanged) {\n        return chartScene({\n            dataStreams,\n            chartSize,\n            container,\n            viewport,\n            minBufferSize,\n            bufferFactor,\n            onUpdate,\n            thresholdOptions,\n            thresholds,\n        });\n    }\n    updateLineMesh({\n        lines,\n        dataStreams,\n        chartSize,\n        viewport,\n        hasDataChanged,\n        toClipSpace: scene.toClipSpace,\n    });\n    updatePointMesh(dataStreams, points, scene.toClipSpace, hasDataChanged);\n    // Return existing scene.\n    return scene;\n};\n\nexport { chartScene as c, updateChartScene as u };\n","/**\n * Line Chart Settings\n */\nconst STROKE_WIDTH = 1.5;\nconst getDataStreamForEventing = (dataStreams) => dataStreams.map(dataStream => ({\n    id: dataStream.id,\n    name: dataStream.name,\n    detailedName: dataStream.detailedName,\n    color: dataStream.color,\n    unit: dataStream.unit,\n    dataType: dataStream.dataType,\n    streamType: dataStream.streamType,\n    associatedStreams: dataStream.associatedStreams,\n    isLoading: dataStream.isLoading,\n    isRefreshing: dataStream.isRefreshing,\n    error: dataStream.error,\n    resolution: dataStream.resolution,\n}));\n\nexport { STROKE_WIDTH as S, getDataStreamForEventing as g };\n","import { c as BufferGeometry, d as ShaderMaterial, P as Points, B as BufferAttribute } from './three.module-8c8bcb27.js';\nimport { g as getCSSColorByString, n as numDataPoints, v as vertices } from './clipSpaceConversion-9fa25666.js';\nimport { a as getNumberThresholds, s as sortThreshold, g as getBreachedThreshold } from './utils-0919edc8.js';\nimport { C as COMPARISON_OPERATOR } from './constants-9d5458e0.js';\nimport { b as isNumberDataStream } from './predicates-248e16b2.js';\n\nconst pointVert = (showColor) => `\nvarying vec3 vColor;\n${showColor ? 'varying float positionY;' : ''}\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  ${showColor ? 'positionY = position.y;' : ''}\n}\n`;\n\nconst shaderFrag = `\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n`;\n\n/**\n * Max of 13 threshold bands because we allow only up to 12 thresholds. Imaging a piece of paper being split into\n * 12 times. You will end up with 13 different pieces.\n */\nconst MAX_THRESHOLD_BANDS = 13;\n/**\n * First we sort the thresholds then reverse it. Reversing the sorted threshold allows us to create the band from\n * top to bottom.\n *\n * For each threshold that is not the first or the last, we check both upper and lower to see if a band is needed.\n *\n * Because we check against the previous threshold and the next threshold, a set is needed to prevent duplicates\n *\n * We know that all the threshold bands can only have unique upper, so we will be using that as the key in the Set.\n */\nconst thresholdBands = (thresholds) => {\n    if (thresholds.length === 0) {\n        return [];\n    }\n    const numberThresholds = getNumberThresholds(thresholds);\n    const sortedThresholds = sortThreshold(numberThresholds).reverse();\n    const bands = [];\n    const thresholdBandsSet = new Set();\n    sortedThresholds.forEach((threshold, index) => {\n        const thresholdValue = threshold.value;\n        if (sortedThresholds[index].comparisonOperator === COMPARISON_OPERATOR.EQUAL) {\n            const [r, g, b] = getCSSColorByString(sortedThresholds[index].color);\n            bands.push({\n                upper: thresholdValue,\n                lower: thresholdValue,\n                color: [r, g, b],\n            });\n            return;\n        }\n        /**\n         * When looking at the first threshold, we want to find a mid point between the MAX SAFE INTEGER and the first\n         * threshold value to determine if the first threshold is an upper bound threshold.\n         */\n        if (index === 0) {\n            const midPoint = (Number.MAX_SAFE_INTEGER + thresholdValue) / 2;\n            const breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n            if (breachedThreshold != null) {\n                const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n                bands.push({\n                    upper: Number.MAX_SAFE_INTEGER,\n                    lower: thresholdValue,\n                    color: [r, g, b],\n                });\n            }\n            return;\n        }\n        /**\n         * When looking at the thresholds that is not the first or the last, we want to compare it with the one before\n         * to make sure if there is an upper band or not.\n         */\n        const prevThreshold = sortedThresholds[index - 1];\n        const prevThresholdValue = prevThreshold.value;\n        let midPoint = (prevThresholdValue + thresholdValue) / 2;\n        let breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n        if (breachedThreshold != null) {\n            if (!thresholdBandsSet.has(prevThreshold.value)) {\n                const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n                if (prevThreshold.comparisonOperator === COMPARISON_OPERATOR.EQUAL &&\n                    prevThreshold.value === sortedThresholds[index].value) {\n                    bands.push({\n                        upper: prevThresholdValue,\n                        lower: thresholdValue,\n                        color: [r, g, b],\n                    });\n                }\n                else {\n                    bands.push({\n                        upper: prevThresholdValue,\n                        lower: thresholdValue,\n                        color: [r, g, b],\n                    });\n                }\n                thresholdBandsSet.add(prevThreshold.value);\n            }\n        }\n        /**\n         * When looking at the last threshold, we want to find the mid point between it and the Min Safe Int\n         * to see if there is a lower band that needs to be create.\n         */\n        if (index === sortedThresholds.length - 1) {\n            midPoint = (thresholdValue + Number.MIN_SAFE_INTEGER) / 2;\n            breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n            if (breachedThreshold != null && !thresholdBandsSet.has(thresholdValue)) {\n                const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n                bands.push({\n                    lower: Number.MIN_SAFE_INTEGER,\n                    upper: thresholdValue,\n                    color: [r, g, b],\n                });\n            }\n            return;\n        }\n        /**\n         * When looking at a threshold that is not first or last, we want to compare it with the next one to see if\n         * a lower band is needed.\n         */\n        const nexThreshold = sortedThresholds[index + 1];\n        const nexThresholdValue = nexThreshold.value;\n        midPoint = (thresholdValue + nexThresholdValue) / 2;\n        breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n        if (breachedThreshold != null && !thresholdBandsSet.has(thresholdValue)) {\n            const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n            bands.push({\n                upper: thresholdValue,\n                lower: nexThresholdValue,\n                color: [r, g, b],\n            });\n            thresholdBandsSet.add(threshold.value);\n        }\n    });\n    /**\n     * Because we need to have a set amount of buffer in Frag, which is 12. If the array length is not 12,\n     * we need to fill in the rest with proper threshold bands. It should be duplicates of the last threshold band\n     *\n     * This function also takes into account when there is only 1 threshold with lower bound.\n     */\n    let lastThresholdBand = bands[bands.length - 1];\n    while (bands.length < MAX_THRESHOLD_BANDS) {\n        const threshold = sortedThresholds[sortedThresholds.length - 1];\n        const thresholdValue = threshold.value;\n        const midPoint = Number.MIN_SAFE_INTEGER + thresholdValue / 2;\n        const breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n        if (breachedThreshold == null) {\n            bands.push(lastThresholdBand);\n        }\n        else {\n            const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n            lastThresholdBand = {\n                lower: Number.MIN_SAFE_INTEGER,\n                upper: thresholdValue,\n                color: [r, g, b],\n            };\n            bands.push(lastThresholdBand);\n        }\n    }\n    return bands;\n};\n\nconst colorationShaderFrag = `\n#define MAX_NUM_TOTAL_THRESHOLD_BAND ${MAX_THRESHOLD_BANDS}\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n`;\n\n/* eslint-disable no-param-reassign */\nconst POINT_MESH_INDEX = 0;\nconst POINT_DIAMETER = 6.25;\nconst RAW_POINT_DIAMETER = 4;\n/**\n * Get the diameter of the points to display on the chart.\n *\n * We want to display points smaller for raw data since they may be displayed very densely\n */\nconst pointDiameter = (dataStreams) => {\n    const resolution = dataStreams[0] != null ? dataStreams[0].resolution : null;\n    return resolution === 0 ? RAW_POINT_DIAMETER : POINT_DIAMETER;\n};\n/**\n * Create Point Mesh\n *\n * The representation of the points on a chart.\n */\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nconst NUM_POSITION_COMPONENTS = 2; // (x, y)\nconst NUM_COLOR_COMPONENTS = 3; // (r, g, b)\n/**\n * Update Geometry\n *\n * Updates the color, and position of the vertices sent down to the vertex shader.\n */\nconst updateGeometry = (geometry, dataStreams, toClipSpace) => {\n    const streamVertexSets = dataStreams.filter(isNumberDataStream).map(stream => vertices(stream, stream.resolution));\n    const allVertices = streamVertexSets.flat();\n    const { position, pointColor } = geometry.attributes;\n    /**\n     * Fill Buffers with data\n     */\n    allVertices.forEach(([x, y, r, g, b], i) => {\n        // Set Position\n        position.array[i * NUM_POSITION_COMPONENTS] = toClipSpace(x);\n        position.array[i * NUM_POSITION_COMPONENTS + 1] = y;\n        // Set Normal Data Stream Color\n        pointColor.array[i * NUM_COLOR_COMPONENTS] = r;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 1] = g;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 2] = b;\n    });\n    geometry.setDrawRange(0, allVertices.length);\n    position.needsUpdate = true;\n    pointColor.needsUpdate = true;\n};\nconst initializeGeometry = (geometry, bufferSize) => {\n    // TODO: Change to double precision\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('pointColor', new BufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\n/**\n * Create Point Mesh\n */\nconst pointMesh = ({ toClipSpace, dataStreams, minBufferSize, bufferFactor, thresholdOptions, thresholds, }) => {\n    const bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    const geometry = new BufferGeometry();\n    initializeGeometry(geometry, bufferSize);\n    updateGeometry(geometry, dataStreams, toClipSpace);\n    const { showColor = true } = thresholdOptions;\n    const material = new ShaderMaterial({\n        vertexShader: pointVert(showColor && thresholds.length > 0),\n        fragmentShader: !showColor || thresholds.length === 0 ? shaderFrag : colorationShaderFrag,\n        transparent: true,\n        uniforms: {\n            pointDiameter: {\n                value: pointDiameter(dataStreams),\n            },\n            devicePixelRatio: {\n                value: window.devicePixelRatio,\n            },\n            thresholdBands: {\n                value: thresholdBands(thresholds),\n            },\n        },\n    });\n    const points = new Points(geometry, material);\n    // Prevent computeBoundingSphere from being called\n    points.frustumCulled = false;\n    return points;\n};\n/**\n * Update Point Mesh\n *\n * Updates the point mesh to match the given data stream info and data streams.\n * Increases size of attribute buffers if necessary.\n */\nconst updatePointMesh = (dataStreams, points, toClipSpace, hasDataChanged = true) => {\n    /**\n     * Update Uniforms\n     *\n     * The uniforms are variables passed into the webgl Shaders.\n     * Learn more about uniforms:\n     * https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms\n     */\n    points.material.uniforms.pointDiameter.value = pointDiameter(dataStreams);\n    points.material.uniforms.devicePixelRatio.value = window.devicePixelRatio;\n    if (hasDataChanged) {\n        updateGeometry(points.geometry, dataStreams, toClipSpace);\n    }\n};\n\nexport { MAX_THRESHOLD_BANDS as M, NUM_POSITION_COMPONENTS as N, POINT_MESH_INDEX as P, pointMesh as p, thresholdBands as t, updatePointMesh as u };\n"],"names":["lineVert","showColor","concat","lineColorationFrag","MAX_THRESHOLD_BANDS","pixelDensity","_ref","_ref$viewport","viewport","end","start","yMax","yMin","toClipSpace","size","width","height","x","Math","abs","getTime","y","LINE_WIDTH","STROKE_WIDTH","updateMesh","dataStreams","mesh","streamVertexSets","filter","isNumberDataStream","map","stream","vertices","resolution","count","reduce","totalSegments","streamVertexSet","max","length","numLineSegments","_geometry$attributes","geometry","attributes","currPoint","nextPoint","segmentColor","positionIndex","colorIndex","forEach","currVertex","vertexNum","nextVertex","_currVertex","_slicedToArray","currX","currY","r","g","b","_nextVertex","nextX","nextY","array","needsUpdate","segmentInstanceGeometry","lineMesh","_ref2","chartSize","minBufferSize","bufferFactor","thresholdOptions","thresholds","InstancedBufferGeometry","bufferSize","numDataPoints","setAttribute","BufferAttribute","Float32Array","flat","InstancedBufferAttribute","Uint8Array","initializeGeometry","_pixelDensity","xPixelDensity","yPixelDensity","_thresholdOptions$sho","lineMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","uniforms","value","thresholdBands","InstancedMesh","frustumCulled","chartScene","_ref4","container","onUpdate","scene","Scene","clipSpaceConversion","numberThresholds","getNumberThresholds","meshList","POINT_MESH_INDEX","pointMesh","add","constructChartScene","updateChartScene","_ref5","hasDataChanged","hasAnnotationChanged","lines","children","points","isDataOverflowingBuffer","position","NUM_POSITION_COMPONENTS$1","maxDataPointsRendered","needsNewClipSpace","_ref3","_pixelDensity2","material","updateLineMesh","updatePointMesh","getDataStreamForEventing","dataStream","id","name","detailedName","color","unit","dataType","streamType","associatedStreams","isLoading","isRefreshing","error","pointVert","sortedThresholds","sortThreshold","reverse","bands","thresholdBandsSet","Set","threshold","index","thresholdValue","comparisonOperator","COMPARISON_OPERATOR","EQUAL","prevThreshold","prevThresholdValue","midPoint","breachedThreshold","getBreachedThreshold","has","_getCSSColorByString5","getCSSColorByString","_getCSSColorByString6","push","upper","lower","nexThresholdValue","_getCSSColorByString9","_getCSSColorByString10","Number","MIN_SAFE_INTEGER","_getCSSColorByString7","_getCSSColorByString8","MAX_SAFE_INTEGER","_getCSSColorByString3","_getCSSColorByString4","_getCSSColorByString","_getCSSColorByString2","lastThresholdBand","_getCSSColorByString11","_getCSSColorByString12","colorationShaderFrag","pointDiameter","NUM_POSITION_COMPONENTS","updateGeometry","allVertices","pointColor","i","setDrawRange","BufferGeometry","ShaderMaterial","devicePixelRatio","window","Points","arguments","undefined"],"sourceRoot":""}