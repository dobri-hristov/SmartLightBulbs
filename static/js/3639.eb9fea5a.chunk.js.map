{"version":3,"file":"static/js/3639.eb9fea5a.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/chartScene-a644ad11.js","../node_modules/@iot-app-kit/components/dist/esm/chartSize-74a4bea8.js","../node_modules/@iot-app-kit/components/dist/esm/getDistanceFromDuration-67232b99.js","../node_modules/@iot-app-kit/components/dist/esm/single-colored-status.entry.js"],"sourcesContent":["import { I as InstancedBufferGeometry, R as RawShaderMaterial, D as DoubleSide, a as InstancedMesh, B as BufferAttribute, b as InstancedBufferAttribute, S as Scene } from './three.module-8c8bcb27.js';\nimport { n as numDataPoints, v as vertices, g as getCSSColorByString, c as constructChartScene, a as clipSpaceConversion, b as needsNewClipSpace } from './clipSpaceConversion-9fa25666.js';\nimport './index-b3f1c3a1.js';\nimport { g as getBreachedThreshold } from './utils-0919edc8.js';\nimport { g as getDistanceFromDuration } from './getDistanceFromDuration-67232b99.js';\n\n/* eslint-disable max-len */\nconst statusVert = `\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nattribute vec4 status;\nattribute vec2 position;\nattribute vec3 color;\nvarying vec3 vColor;\n\nvoid main() {\n  float width = status.z;\n  float height = status.w;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * width + status.x, position.y * height + status.y, 0.0, 1.0);\n  vColor = color;\n}\n`;\n\nconst statusFrag = `\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n`;\n\n/**\n * Display Constants\n *\n * Adjust these to scale the margins provided within the status chart.\n * This represent which fraction of the 'width' of a given status group a margin.\n */\nconst HEIGHT = 1;\n// a small fudge factor due to the anti aliasing applied on the edges of the visualization.\n// the ideal solution would be to fix the shader to give a crisp line.\nconst MARGIN_FUDGE_FACTOR = 0.5;\n// must match css variable --timeline-row-margin-top, with a small fudge factor removed\nconst STATUS_MARGIN_TOP_PX = 34 - MARGIN_FUDGE_FACTOR;\nconst DEFAULT_STATUS_BAR_COLOR_1 = [213, 219, 219]; // (r, g, b) from 0 to 255\nconst DEFAULT_STATUS_BAR_COLOR_2 = [135, 149, 150]; // (r, g, b) from 0 to 255\n\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nconst NUM_POSITION_COMPONENTS = 2; // (x, y)\nconst NUM_STATUS_COMPONENTS = 4; // (x, y, width, height)\nconst NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nconst numStatuses = (streamVertexSets) => streamVertexSets.reduce((totalStatuses, streamVertexSet) => {\n    const streamStatuses = Math.max(streamVertexSet.length, 0);\n    return totalStatuses + streamStatuses;\n}, 0);\n/**\n * Returns clip space width of the bar\n */\nconst getWidth = ({ nextX, currX, toClipSpace, alarms, }) => {\n    const expires = alarms ? alarms.expires : undefined;\n    if (expires != null) {\n        // If we have a staleness, render the bar until it either:\n        //  - collides with the next point's x value\n        //  - extends to the duration of the staleness\n        const maxWidth = getDistanceFromDuration(toClipSpace, expires);\n        if (nextX == null) {\n            return maxWidth;\n        }\n        return Math.min(getDistanceFromDuration(toClipSpace, nextX - currX), maxWidth);\n    }\n    // If we have a point that comes after this point, extend till that point\n    if (nextX != null) {\n        return getDistanceFromDuration(toClipSpace, nextX - currX);\n    }\n    // Extend bar 'til present time\n    return getDistanceFromDuration(toClipSpace, Date.now() - currX);\n};\nconst updateMesh = ({ dataStreams, mesh, toClipSpace, thresholds, thresholdOptions, chartSize, alarms, }) => {\n    const streamVertexSets = dataStreams.map(stream => vertices(stream, stream.resolution));\n    // Set the number of instances of the status are to be rendered.\n    // eslint-disable-next-line no-param-reassign\n    mesh.count = numStatuses(streamVertexSets);\n    const { geometry } = mesh;\n    const { color, status } = geometry.attributes;\n    let statusIndex = 0;\n    let colorIndex = 0;\n    /** Layout */\n    const rowHeight = HEIGHT / dataStreams.length;\n    const margin = STATUS_MARGIN_TOP_PX / chartSize.height;\n    const vizHeight = rowHeight - margin;\n    streamVertexSets.forEach((streamVertexSet, setIndex) => {\n        let prevY;\n        let currentDefaultGrayColor = DEFAULT_STATUS_BAR_COLOR_1;\n        streamVertexSet.forEach((currVertex, v) => {\n            const nextVertex = streamVertexSet[v + 1];\n            const [nextX = undefined] = nextVertex || [];\n            const [currX, currY] = currVertex;\n            if (prevY != null && prevY !== currY) {\n                // Swap grays if data value has changed since last point. Don't want to change color of the data point has the same value as the previous data point.\n                currentDefaultGrayColor =\n                    currentDefaultGrayColor === DEFAULT_STATUS_BAR_COLOR_1\n                        ? DEFAULT_STATUS_BAR_COLOR_2\n                        : DEFAULT_STATUS_BAR_COLOR_1;\n            }\n            /**\n             * Color Buffer Construction\n             */\n            const breachedThreshold = getBreachedThreshold(currY, thresholds);\n            if (breachedThreshold == null || !thresholdOptions.showColor) {\n                const [r, g, b] = currentDefaultGrayColor;\n                // The status-timeline alternates between two grays as a default color.\n                // This provides visual contrast when the data value changes, without\n                // requiring a user to specify every threshold in advance.\n                // In certain use cases of the status-timeline, the values visualized cannot be known ahead of time,\n                // but users still need to be able to visually differentiate when they change.\n                color.array[colorIndex] = r;\n                color.array[colorIndex + 1] = g;\n                color.array[colorIndex + 2] = b;\n            }\n            else {\n                const [rr, gg, bb] = getCSSColorByString(breachedThreshold.color);\n                // Set breached threshold color (r, g, b)\n                color.array[colorIndex] = rr;\n                color.array[colorIndex + 1] = gg;\n                color.array[colorIndex + 2] = bb;\n            }\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            /**\n             * Position Buffer Construction\n             *\n             * The 'y range' varies from 0 to 1 (HEIGHT). We need to convert pixels over to clip space\n             */\n            // status x\n            status.array[statusIndex] = toClipSpace(currX);\n            // status y\n            status.array[statusIndex + 1] = HEIGHT - rowHeight * (setIndex + 1);\n            // status width\n            status.array[statusIndex + 2] = getWidth({ currX, nextX, toClipSpace, alarms });\n            // status height\n            status.array[statusIndex + 3] = vizHeight;\n            // Increment Indexes by the associated stride of the buffer\n            statusIndex += NUM_STATUS_COMPONENTS;\n            prevY = currY;\n        });\n    });\n    status.needsUpdate = true;\n    color.needsUpdate = true;\n};\n// https://wwwtyro.net/2019/11/18/instanced-lines.html\n// 2d vertices composing of two triangles which make up a square\n// (0, 1) - - - (1, 1)\n//   |  \\         |\n//   |     \\      |\n//   |        \\   |\n// (0, 0) - - - (1, 0)\nconst unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];\nconst initializeGeometry = (geometry, bufferSize) => {\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('status', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_STATUS_COMPONENTS), NUM_STATUS_COMPONENTS, false));\n    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nconst statusMesh = ({ alarms, dataStreams, toClipSpace, bufferFactor, minBufferSize, thresholdOptions, thresholds, chartSize, }) => {\n    const instGeo = new InstancedBufferGeometry();\n    const bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(instGeo, bufferSize);\n    /**\n     * Create Status Mesh\n     *\n     * The representation of the statuses on a status chart.\n     *\n     * Utilizes an instance of a single unit square, which then gets\n     * stretched and transposed across the canvas.\n     */\n    const statusChartMaterial = new RawShaderMaterial({\n        vertexShader: statusVert,\n        fragmentShader: statusFrag,\n        side: DoubleSide,\n        transparent: false,\n    });\n    const mesh = new InstancedMesh(instGeo, statusChartMaterial, bufferSize);\n    updateMesh({\n        dataStreams,\n        mesh,\n        toClipSpace,\n        thresholds,\n        thresholdOptions,\n        chartSize,\n        alarms,\n    });\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    return mesh;\n};\nconst updateStatusMesh = ({ alarms, statuses, dataStreams, toClipSpace, thresholdOptions, thresholds, chartSize, hasDataChanged, hasAnnotationChanged, hasSizeChanged, }) => {\n    if (hasDataChanged || hasAnnotationChanged || hasSizeChanged) {\n        updateMesh({\n            dataStreams,\n            mesh: statuses,\n            toClipSpace,\n            thresholds,\n            thresholdOptions,\n            chartSize,\n            alarms,\n        });\n    }\n};\n\nconst maxDataPointsRendered = (statuses) => statuses.geometry.attributes.status.array.length / NUM_STATUS_COMPONENTS;\nconst chartScene = ({ alarms, dataStreams, container, viewport, bufferFactor, minBufferSize, onUpdate, thresholdOptions, thresholds, chartSize, }) => {\n    const scene = new Scene();\n    const toClipSpace = clipSpaceConversion(viewport);\n    scene.add(statusMesh({\n        alarms,\n        dataStreams,\n        toClipSpace,\n        bufferFactor,\n        minBufferSize,\n        thresholdOptions,\n        thresholds,\n        chartSize,\n    }));\n    return constructChartScene({ scene, viewport, container, toClipSpace, onUpdate });\n};\nconst updateChartScene = ({ scene, alarms, dataStreams, minBufferSize, bufferFactor, viewport, container, onUpdate, chartSize, thresholdOptions, thresholds, hasDataChanged, hasAnnotationChanged, hasSizeChanged, }) => {\n    const statuses = scene.scene.children[0];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    const isDataOverflowingBuffer = maxDataPointsRendered(statuses) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace)) {\n        return chartScene({\n            onUpdate,\n            dataStreams,\n            alarms,\n            container,\n            viewport,\n            minBufferSize,\n            bufferFactor,\n            chartSize,\n            thresholdOptions,\n            thresholds,\n        });\n    }\n    updateStatusMesh({\n        alarms,\n        statuses,\n        dataStreams,\n        toClipSpace: scene.toClipSpace,\n        thresholdOptions,\n        thresholds,\n        chartSize,\n        hasDataChanged,\n        hasAnnotationChanged,\n        hasSizeChanged,\n    });\n    return scene;\n};\n\nexport { HEIGHT as H, STATUS_MARGIN_TOP_PX as S, chartScene as c, updateChartScene as u };\n","const CHART_SIZE = {\n    width: 100,\n    height: 100,\n};\n\nexport { CHART_SIZE as C };\n","/**\n *\n * Get Distance from Duration\n *\n * Return distance between `milliseconds` on a given `xScale`, assuming `xScale` is linear.\n * If `xScale` is not linear, the distance between two points can depend on the exact value of time,\n * rather than just the time between. Non-linear `xScale` requires the width to be computed for every point rather\n * than just once.\n *\n * Since a non-linear xAxis is an un-common use case we won't support that for now.\n */\nconst getDistanceFromDuration = (toClipSpace, milliseconds) => Math.abs(toClipSpace(new Date(milliseconds).getTime()) - toClipSpace(new Date(0).getTime()));\n\nexport { getDistanceFromDuration as g };\n","import { r as registerInstance, h, g as getElement } from './index-1cec361c.js';\nimport { w as webGLRenderer } from './webglContext-6c9fd90d.js';\nimport { c as chartScene, H as HEIGHT } from './chartScene-a644ad11.js';\nimport { C as CHART_SIZE } from './chartSize-74a4bea8.js';\nimport { D as DAY_IN_MS } from './time-b684d8c5.js';\nimport { D as DataType } from './dataConstants-71f11842.js';\nimport './three.module-8c8bcb27.js';\nimport './predicates-248e16b2.js';\nimport './clipSpaceConversion-9fa25666.js';\nimport './v4-b6bb7e11.js';\nimport './_commonjsHelpers-f9dc4873.js';\nimport './getDataPoints-c53771e0.js';\nimport './index-42a9af88.js';\nimport './index-b3f1c3a1.js';\nimport './utils-0919edc8.js';\nimport './number-3e8376bf.js';\nimport './constants-9d5458e0.js';\nimport './bisector-ecf52045.js';\nimport './getDistanceFromDuration-67232b99.js';\n\n// viewport boundaries\nconst X_MIN = new Date(2000, 0, 0);\nconst X_MAX = new Date(2000, 0, 1);\nconst WIDTH = X_MAX.getTime() - X_MIN.getTime();\nconst TEST_DATA_POINT_1 = {\n  x: X_MIN.getTime() + WIDTH / 3,\n  y: 123,\n};\nconst SingleColoredStatus = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n  }\n  componentDidLoad() {\n    const container = this.el.querySelector('#test-container');\n    const scene = chartScene({\n      alarms: { expires: DAY_IN_MS },\n      viewport: {\n        start: X_MIN,\n        end: X_MAX,\n        yMin: 0,\n        yMax: HEIGHT,\n      },\n      dataStreams: [\n        {\n          id: 'test-stream',\n          name: 'test-stream-name',\n          color: 'red',\n          aggregates: {\n            [DAY_IN_MS]: [TEST_DATA_POINT_1],\n          },\n          data: [],\n          resolution: DAY_IN_MS,\n          dataType: DataType.NUMBER,\n        },\n      ],\n      container,\n      chartSize: CHART_SIZE,\n      minBufferSize: 100,\n      bufferFactor: 2,\n      thresholdOptions: {\n        showColor: false,\n      },\n      thresholds: [],\n    });\n    webGLRenderer.addChartScene({ manager: scene });\n    const rect = container.getBoundingClientRect();\n    webGLRenderer.setChartRect(scene.id, Object.assign({ density: 1 }, rect.toJSON()));\n  }\n  render() {\n    return (h(\"sc-webgl-context\", null, h(\"div\", { id: \"test-container\", style: { width: `${CHART_SIZE.width}px`, height: `${CHART_SIZE.height}px` } })));\n  }\n  get el() { return getElement(this); }\n};\n\nexport { SingleColoredStatus as single_colored_status };\n"],"names":["HEIGHT","STATUS_MARGIN_TOP_PX","DEFAULT_STATUS_BAR_COLOR_1","DEFAULT_STATUS_BAR_COLOR_2","updateMesh","_ref2","dataStreams","mesh","toClipSpace","thresholds","thresholdOptions","chartSize","alarms","streamVertexSets","map","stream","vertices","resolution","count","reduce","totalStatuses","streamVertexSet","Math","max","length","numStatuses","_geometry$attributes","geometry","attributes","color","status","statusIndex","colorIndex","rowHeight","margin","height","vizHeight","forEach","setIndex","prevY","currentDefaultGrayColor","currVertex","v","_ref3","_ref4$","_slicedToArray","nextX","undefined","_currVertex","currX","currY","breachedThreshold","getBreachedThreshold","showColor","_getCSSColorByString","getCSSColorByString","_getCSSColorByString2","rr","gg","bb","array","_currentDefaultGrayCo","_currentDefaultGrayCo2","r","g","b","_ref","expires","maxWidth","getDistanceFromDuration","min","Date","now","getWidth","needsUpdate","unitSquare","statusMesh","_ref5","bufferFactor","minBufferSize","instGeo","InstancedBufferGeometry","bufferSize","numDataPoints","setAttribute","BufferAttribute","Float32Array","InstancedBufferAttribute","Uint8Array","initializeGeometry","statusChartMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","InstancedMesh","frustumCulled","chartScene","_ref7","container","viewport","onUpdate","scene","Scene","clipSpaceConversion","add","constructChartScene","updateChartScene","_ref8","hasDataChanged","hasAnnotationChanged","hasSizeChanged","statuses","children","isDataOverflowingBuffer","maxDataPointsRendered","needsNewClipSpace","_ref6","updateStatusMesh","CHART_SIZE","width","milliseconds","abs","getTime","X_MIN","X_MAX","WIDTH","TEST_DATA_POINT_1","x","y","SingleColoredStatus","hostRef","_classCallCheck","registerInstance","this","_createClass","key","value","el","querySelector","DAY_IN_MS","start","end","yMin","yMax","id","name","aggregates","_defineProperty","data","dataType","DataType","NUMBER","webGLRenderer","addChartScene","manager","rect","getBoundingClientRect","setChartRect","Object","assign","density","toJSON","h","style","concat","get","getElement"],"sourceRoot":""}