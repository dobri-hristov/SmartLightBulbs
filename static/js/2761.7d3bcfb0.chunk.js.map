{"version":3,"file":"static/js/2761.7d3bcfb0.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/breachedThreshold-ec78e357.js","../node_modules/@iot-app-kit/components/dist/esm/constants-3de41941.js","../node_modules/@iot-app-kit/components/dist/esm/constructTableData-0bdc96c5.js","../node_modules/@iot-app-kit/components/dist/esm/dataFilters-fa384f64.js","../node_modules/@iot-app-kit/components/dist/esm/sc-table.entry.js","../node_modules/@iot-app-kit/components/dist/esm/viewPort-358a51a4.js"],"sourcesContent":["import { g as getBreachedThreshold } from './utils-0919edc8.js';\nimport { c as isDefined } from './predicates-248e16b2.js';\nimport { p as pointBisector, g as getDataBeforeDate } from './dataFilters-fa384f64.js';\nimport { g as getDataPoints } from './getDataPoints-c53771e0.js';\nimport { D as DATA_ALIGNMENT } from './constants-9d5458e0.js';\nimport { S as StreamType } from './dataConstants-71f11842.js';\n\n/**\n * Sorts points in order of their points values.\n * Places objects with no point at the end of the list.\n */\nconst sortTooltipPoints = (attr) => (a, b) => {\n    if (a.point == null && b.point == null) {\n        return 0;\n    }\n    if (a.point == null) {\n        return -1;\n    }\n    if (b.point == null) {\n        return 1;\n    }\n    if (attr(a.point) === attr(b.point)) {\n        return 0;\n    }\n    return attr(b.point) > attr(a.point) ? 1 : -1;\n};\n\n/**\n * Closest Points\n *\n * Returns the closest point to the left, and right of a\n * given point in time..\n *\n * @param maxDistance - maximum distance, measured in terms of milliseconds. if not present, there is no max distance.\n */\nconst closestPoint = (dataPoints, date, dataAlignment, maxDistance) => {\n    const idx = pointBisector.left(dataPoints, date);\n    const leftPoint = dataPoints[idx - 1];\n    const rightPoint = dataPoints[idx];\n    /**\n     * If a point falls on our point of time, return it immediately regardless of 'data alignment'.\n     */\n    if (leftPoint && leftPoint.x === date.getTime()) {\n        return leftPoint;\n    }\n    if (rightPoint && rightPoint.x === date.getTime()) {\n        return rightPoint;\n    }\n    /** Right Alignment */\n    if (dataAlignment === DATA_ALIGNMENT.RIGHT) {\n        if (!rightPoint) {\n            return undefined;\n        }\n        if (maxDistance == null) {\n            return rightPoint;\n        }\n        return rightPoint.x - date.getTime() <= maxDistance ? rightPoint : undefined;\n    }\n    /** Left Alignment */\n    if (dataAlignment === DATA_ALIGNMENT.LEFT) {\n        if (!leftPoint) {\n            return undefined;\n        }\n        if (maxDistance == null) {\n            return leftPoint;\n        }\n        return date.getTime() - leftPoint.x <= maxDistance ? leftPoint : undefined;\n    }\n    /** Either Alignment */\n    // If only the left, or only the right point exist, go ahead and just return it.\n    if (!leftPoint || !rightPoint) {\n        return leftPoint || rightPoint;\n    }\n    // We are right bias because the interval between two points is the time span for the point on the right.\n    return rightPoint;\n};\n/**\n * Get Active Points\n *\n * Returns at most one point per data stream - for each data stream, it finds the point which is\n * 1. within the given view port\n * 2. closest to the provided `selectedDate`\n *\n * Additionally, if `allowMultipleDates` is false, it will only return the points which are the closest\n * to the `selectedDate`. i.e. if you have 10 points that are all equally distant from the `selectedDate`,\n * all 10 are returned.\n *\n * However if you have 10 points of different dates, only the closest point would be returned.\n */\nconst activePoints = ({ viewport, dataStreams, selectedDate, allowMultipleDates, dataAlignment, maxDurationFromDate, }) => {\n    const dataStreamUtilizedData = dataStreams.map(stream => ({\n        streamId: stream.id,\n        dataPoints: getDataBeforeDate(getDataPoints(stream, stream.resolution), viewport.end),\n    }));\n    const selectedTimestamp = selectedDate.getTime();\n    // Find the closest point to the selected date for each stream\n    const points = dataStreamUtilizedData.map(({ streamId, dataPoints }) => ({\n        streamId,\n        point: closestPoint(dataPoints, selectedDate, dataAlignment, maxDurationFromDate),\n    }));\n    if (allowMultipleDates) {\n        return points;\n    }\n    const distanceFromDate = (p) => Math.abs(p.x - selectedTimestamp);\n    // Sort in ascending order by there distance from the selected date\n    const sortedPoints = points.sort(sortTooltipPoints(distanceFromDate));\n    if (sortedPoints.length === 0) {\n        return [];\n    }\n    const topPoint = sortedPoints[sortedPoints.length - 1].point;\n    if (topPoint == null) {\n        // everything must be a 'blank' point\n        return sortedPoints;\n    }\n    // Filter such that only the points with a date equal to the date of the point which is closest to the selected date.\n    return sortedPoints.filter(p => p.point && p.point.x === topPoint.x);\n};\n\nconst isHigherPriority = (t1, t2) => {\n    if (t1 == null) {\n        return t2;\n    }\n    if (t1.severity == null && t2.severity == null) {\n        return t1;\n    }\n    if (t1.severity == null) {\n        return t2;\n    }\n    if (t2.severity == null) {\n        return t1;\n    }\n    return t1.severity <= t2.severity ? t1 : t2;\n};\n/**\n * Returns the most important threshold.\n *\n * The most important threshold is the visual which is most important to a user\n * This is determined via the `severity`. Lower severity means highest importance.\n *\n * If no thresholds are present with `severity`, the first threshold is returned.\n */\nconst highestPriorityThreshold = (thresholds) => {\n    return thresholds.reduce(isHigherPriority, undefined);\n};\n/**\n * returns whether the given threshold can be applied to the requested data stream.\n *\n * EXPOSED FOR TESTING\n */\nconst thresholdAppliesToDataStream = (threshold, dataStreamId) => {\n    const { dataStreamIds } = threshold;\n    if (dataStreamIds == null) {\n        return true;\n    }\n    return dataStreamIds.includes(dataStreamId);\n};\n/**\n * Returns all of the breached thresholds for any of the alarms associated with the requested data stream.\n *\n * Does NOT return them in any sort of priority order.\n *\n * EXPOSED FOR TESTING\n */\nconst breachedAlarmThresholds = ({ date, dataStream, dataStreams, thresholds, }) => {\n    const alarmStreamIds = dataStream.associatedStreams != null\n        ? dataStream.associatedStreams.filter(({ type }) => type === StreamType.ALARM).map(({ id }) => id)\n        : [];\n    const isAssociatedAlarm = (stream) => alarmStreamIds.includes(stream.id);\n    const alarmStreams = dataStreams.filter(isAssociatedAlarm);\n    // thresholds considered breech, across all alarms for the requested data stream\n    const allBreachedAlarmThresholds = alarmStreams\n        .map(stream => {\n        const alarmThresholds = thresholds.filter(threshold => thresholdAppliesToDataStream(threshold, stream.id));\n        const latestAlarmValue = closestPoint(stream.data, date, DATA_ALIGNMENT.LEFT);\n        return latestAlarmValue != null ? getBreachedThreshold(latestAlarmValue.y, alarmThresholds) : undefined;\n    })\n        .filter(isDefined);\n    return allBreachedAlarmThresholds;\n};\n/**\n * Get the highest priority breached threshold.\n *\n * NOTE: If you do not want to get alarm thresholds, simply pass in an empty array for the `dataStreams`.\n */\nconst breachedThreshold = ({ value, date, thresholds, dataStreams, dataStream, }) => {\n    const applicableThresholds = thresholds.filter(threshold => thresholdAppliesToDataStream(threshold, dataStream.id));\n    const dataThreshold = value != null ? getBreachedThreshold(value, applicableThresholds) : undefined;\n    const alarmThresholds = breachedAlarmThresholds({\n        date,\n        dataStream,\n        dataStreams,\n        thresholds,\n    });\n    return highestPriorityThreshold([dataThreshold, ...alarmThresholds].filter(isDefined));\n};\n\nexport { activePoints as a, breachedThreshold as b, closestPoint as c, sortTooltipPoints as s };\n","import { b as commonjsGlobal } from './_commonjsHelpers-f9dc4873.js';\nimport { S as SECOND_IN_MS } from './time-b684d8c5.js';\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nvar lodash_throttle = throttle;\n\nconst DATE_RANGE_EMIT_EVENT_MS = 0.5 * SECOND_IN_MS;\n\nexport { DATE_RANGE_EMIT_EVENT_MS as D, lodash_throttle as l };\n","import { b as breachedThreshold } from './breachedThreshold-ec78e357.js';\nimport { g as getDataPoints } from './getDataPoints-c53771e0.js';\n\nconst cell = (thresholds, date, dataStreams, dataStreamId) => {\n    const stream = dataStreams.find(({ id }) => id === dataStreamId);\n    const points = stream ? getDataPoints(stream, stream.resolution) : [];\n    const value = points[points.length - 1] && points[points.length - 1].y;\n    const threshold = stream &&\n        breachedThreshold({\n            value,\n            date,\n            dataStreams,\n            dataStream: stream,\n            thresholds,\n        });\n    const { color, icon } = threshold || {};\n    return { dataStream: stream, color, icon };\n};\n/**\n * Given the business models, output the view model representation of a table row.\n */\nconst constructTableData = ({ tableColumns, dataStreams, thresholds, date, }) => {\n    const numRows = Math.max(...tableColumns.map(({ rows }) => rows.length));\n    const table = [];\n    // eslint-disable-next-line no-plusplus\n    for (let r = 0; r < numRows; r++) {\n        const row = {};\n        tableColumns.forEach(column => {\n            const dataStreamId = column.rows[r] || undefined;\n            row[column.header] = cell(thresholds, date, dataStreams, dataStreamId);\n        });\n        table.push(row);\n    }\n    return table;\n};\n/**\n * Format liveModeOnlyMessage for Table disable State display\n */\nconst formatLiveModeOnlyMessage = (liveModeOnlyMessage) => {\n    const splitIndex = liveModeOnlyMessage.indexOf('. ');\n    if (splitIndex < 0) {\n        return { msgHeader: liveModeOnlyMessage, msgSubHeader: '' };\n    }\n    const msgHeader = liveModeOnlyMessage.slice(0, splitIndex);\n    const msgSubHeader = liveModeOnlyMessage.slice(splitIndex + 2);\n    return { msgHeader, msgSubHeader };\n};\n\nexport { constructTableData as c, formatLiveModeOnlyMessage as f };\n","import { a as isMinimalStaticViewport } from './predicates-248e16b2.js';\nimport { p as parseDuration } from './time-b684d8c5.js';\nimport { b as bisector } from './bisector-ecf52045.js';\n\n// By doing the mapping to a date within the bisector\n// we eliminate the need to iterate over the entire data.\n// (As opposed to mapping entire data to an array of dates)\nconst pointBisector = bisector((p) => p.x);\n/**\n * Get Visible Data\n *\n * Returns the data points which are required for the chart to correctly render.\n * This assumes linear interpolation between points\n * TODO: Support other interpolation methods\n *\n * NOTE: It's possible to have data not in the viewport which is required for the chart to render\n * it's fully visualization correctly. For Instance, even if a point isn't visible in the viewport, it may\n * be used within interpolation to calculate a path between the points which is within the viewport.\n *\n * Different interpolation methods need larger amount of context around the viewport to correctly render\n * the chart visualization.\n */\nconst getVisibleData = (data, viewport, \n// Whether we want to include a single point to the right, and to the left of the provide viewport.\n// This is useful when rendering lines since you need to connect a point to a point outside of the viewport\n// to fully render the data correctly.\nincludeBoundaryPoints = true) => {\n    const start = isMinimalStaticViewport(viewport)\n        ? new Date(viewport.start)\n        : new Date(Date.now() - parseDuration(viewport.duration));\n    const end = isMinimalStaticViewport(viewport) ? new Date(viewport.end) : new Date();\n    // If there is no data\n    if (data.length === 0) {\n        return [];\n    }\n    // If all data is before the view port\n    if (start.getTime() > data[data.length - 1].x) {\n        return [];\n    }\n    // If all data is after the view port\n    if (end.getTime() < data[0].x) {\n        return [];\n    }\n    // Otherwise return all the data within the viewport, plus an additional single data point that falls outside of\n    // the viewport in either direction.\n    const startIndex = Math.max(pointBisector.left(data, start) - (includeBoundaryPoints ? 1 : 0), 0);\n    const endIndex = Math.min(pointBisector.right(data, end) - (includeBoundaryPoints ? 0 : 1), data.length - 1);\n    return data.slice(startIndex, endIndex + 1);\n};\n/**\n * Returns all data before or at the given date.\n *\n * Assumes data is ordered chronologically.\n */\nconst getDataBeforeDate = (data, date) => {\n    // If there is no data\n    if (data.length === 0) {\n        return [];\n    }\n    // If all data is after the view port\n    if (date.getTime() < data[0].x) {\n        return [];\n    }\n    // Otherwise return all the data within the viewport, plus an additional single data point that falls outside of\n    // the viewport in either direction.\n    const endIndex = Math.min(pointBisector.right(data, date) - 1, data.length - 1);\n    return data.slice(0, endIndex + 1);\n};\n\nexport { getVisibleData as a, getDataBeforeDate as g, pointBisector as p };\n","import { r as registerInstance, c as createEvent, h } from './index-1cec361c.js';\nimport { l as lodash_throttle, D as DATE_RANGE_EMIT_EVENT_MS } from './constants-3de41941.js';\nimport { i as isThreshold } from './utils-0919edc8.js';\nimport { c as constructTableData } from './constructTableData-0bdc96c5.js';\nimport { v as viewportStartDate, a as viewportEndDate, i as isInLiveMode } from './viewPort-358a51a4.js';\nimport { a as isMinimalStaticViewport } from './predicates-248e16b2.js';\nimport { p as parseDuration } from './time-b684d8c5.js';\nimport { w as webGLRenderer } from './webglContext-6c9fd90d.js';\nimport './_commonjsHelpers-f9dc4873.js';\nimport './number-3e8376bf.js';\nimport './constants-9d5458e0.js';\nimport './bisector-ecf52045.js';\nimport './breachedThreshold-ec78e357.js';\nimport './dataFilters-fa384f64.js';\nimport './getDataPoints-c53771e0.js';\nimport './dataConstants-71f11842.js';\nimport './index-b3f1c3a1.js';\nimport './three.module-8c8bcb27.js';\n\nconst ScTable = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.dateRangeChange = createEvent(this, \"dateRangeChange\", 7);\n    this.messageOverrides = {};\n    /** Active Viewport */\n    this.start = viewportStartDate(this.viewport);\n    this.end = viewportEndDate(this.viewport);\n    this.duration = !isMinimalStaticViewport(this.viewport)\n      ? parseDuration(this.viewport.duration)\n      : undefined;\n    this.onUpdate = ({ start, end, duration }) => {\n      const hasViewPortChanged = viewportStartDate(this.viewport).getTime() !== start.getTime() ||\n        viewportEndDate(this.viewport).getTime() !== end.getTime();\n      const inLiveMode = isInLiveMode(this.viewport);\n      if (hasViewPortChanged && !inLiveMode) {\n        this.onDateRangeChange([start, end, this.viewport.group]);\n      }\n      // Update active viewport\n      this.start = start;\n      this.end = end;\n      this.duration = duration;\n    };\n    this.onDateRangeChange = lodash_throttle(([start, end, from]) => {\n      this.dateRangeChange.emit([start, end, from]);\n    }, DATE_RANGE_EMIT_EVENT_MS, {\n      leading: true,\n      trailing: true,\n    });\n    this.getThresholds = () => this.annotations && this.annotations.y ? this.annotations.y.filter(isThreshold) : [];\n  }\n  onViewPortChange(newViewPort) {\n    this.onUpdate(Object.assign(Object.assign({}, newViewPort), { duration: !isMinimalStaticViewport(newViewPort) ? parseDuration(newViewPort.duration) : undefined, start: viewportStartDate(this.viewport), end: viewportEndDate(this.viewport) }));\n  }\n  componentDidLoad() {\n    webGLRenderer.addChartScene({\n      manager: {\n        id: this.widgetId,\n        viewportGroup: this.viewport.group,\n        updateViewPort: this.onUpdate,\n      },\n      duration: this.duration,\n    });\n  }\n  disconnectedCallback() {\n    // necessary to make sure that the allocated memory is released, and nothing is incorrectly rendered.\n    webGLRenderer.removeChartScene(this.widgetId);\n  }\n  render() {\n    const rows = constructTableData({\n      tableColumns: this.tableColumns,\n      dataStreams: this.dataStreams,\n      thresholds: this.getThresholds(),\n      date: this.end,\n    });\n    const isEnabled = this.duration != null;\n    return (h(\"sc-table-base\", { columns: this.tableColumns, rows: rows, isEnabled: isEnabled, messageOverrides: this.messageOverrides }));\n  }\n  static get watchers() { return {\n    \"viewport\": [\"onViewPortChange\"]\n  }; }\n};\n\nexport { ScTable as sc_table };\n","import { a as isMinimalStaticViewport } from './predicates-248e16b2.js';\nimport { p as parseDuration } from './time-b684d8c5.js';\n\nconst viewportStartDate = (viewportConfig) => isMinimalStaticViewport(viewportConfig)\n    ? new Date(viewportConfig.start)\n    : new Date(Date.now() - parseDuration(viewportConfig.duration));\nconst viewportEndDate = (viewportConfig) => {\n    return isMinimalStaticViewport(viewportConfig) ? new Date(viewportConfig.end) : new Date(Date.now());\n};\nconst isInLiveMode = (viewport) => {\n    return !isMinimalStaticViewport(viewport) && Boolean(viewport.duration);\n};\n\nexport { viewportEndDate as a, isInLiveMode as i, viewportStartDate as v };\n"],"names":["sortTooltipPoints","attr","a","b","point","closestPoint","dataPoints","date","dataAlignment","maxDistance","idx","pointBisector","left","leftPoint","rightPoint","x","getTime","DATA_ALIGNMENT","RIGHT","undefined","LEFT","activePoints","_ref","viewport","dataStreams","selectedDate","allowMultipleDates","maxDurationFromDate","dataStreamUtilizedData","map","stream","streamId","id","getDataBeforeDate","getDataPoints","resolution","end","selectedTimestamp","points","_ref2","sortedPoints","sort","p","Math","abs","length","topPoint","filter","isHigherPriority","t1","t2","severity","thresholdAppliesToDataStream","threshold","dataStreamId","dataStreamIds","includes","breachedThreshold","_ref6","value","thresholds","dataStream","applicableThresholds","dataThreshold","getBreachedThreshold","alarmThresholds","_ref3","alarmStreamIds","associatedStreams","_ref4","type","StreamType","ALARM","_ref5","latestAlarmValue","data","y","isDefined","breachedAlarmThresholds","reduce","highestPriorityThreshold","concat","_toConsumableArray","FUNC_ERROR_TEXT","NAN","symbolTag","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","freeGlobal","commonjsGlobal","Object","freeSelf","self","root","Function","objectToString","prototype","toString","nativeMax","max","nativeMin","min","now","Date","debounce","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","remainingWait","debounced","isInvoking","arguments","this","leadingEdge","toNumber","isObject","cancel","clearTimeout","flush","isObjectLike","call","isSymbol","other","valueOf","replace","isBinary","test","slice","lodash_throttle","DATE_RANGE_EMIT_EVENT_MS","SECOND_IN_MS","constructTableData","tableColumns","numRows","rows","table","_loop","r","row","forEach","column","header","find","color","icon","cell","push","formatLiveModeOnlyMessage","liveModeOnlyMessage","splitIndex","indexOf","msgHeader","msgSubHeader","bisector","getVisibleData","includeBoundaryPoints","start","isMinimalStaticViewport","parseDuration","duration","startIndex","endIndex","right","ScTable","hostRef","_this","_classCallCheck","registerInstance","dateRangeChange","createEvent","messageOverrides","viewportStartDate","viewportEndDate","onUpdate","hasViewPortChanged","inLiveMode","isInLiveMode","onDateRangeChange","group","_slicedToArray","from","emit","getThresholds","annotations","isThreshold","_createClass","key","newViewPort","assign","webGLRenderer","addChartScene","manager","widgetId","viewportGroup","updateViewPort","removeChartScene","isEnabled","h","columns","get","viewportConfig","Boolean"],"sourceRoot":""}