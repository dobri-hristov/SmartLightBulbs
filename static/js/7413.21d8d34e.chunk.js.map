{"version":3,"file":"static/js/7413.21d8d34e.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/active-router-8f9f6b80.js","../node_modules/@iot-app-kit/components/dist/esm/dom-utils-97f33dea.js"],"sourcesContent":["import { h } from './index-1cec361c.js';\n\nconst createProviderConsumer = (defaultState, consumerRender) => {\r\n    let listeners = new Map();\r\n    let currentState = defaultState;\r\n    const updateListener = (fields, instance) => {\r\n        if (Array.isArray(fields)) {\r\n            [...fields].forEach(fieldName => {\r\n                instance[fieldName] = currentState[fieldName];\r\n            });\r\n        }\r\n        else {\r\n            instance[fields] = Object.assign({}, currentState);\r\n        }\r\n    };\r\n    const subscribe = (instance, propList) => {\r\n        if (!listeners.has(instance)) {\r\n            listeners.set(instance, propList);\r\n            updateListener(propList, instance);\r\n        }\r\n        return () => {\r\n            if (listeners.has(instance)) {\r\n                listeners.delete(instance);\r\n            }\r\n        };\r\n    };\r\n    const Provider = ({ state }, children) => {\r\n        currentState = state;\r\n        listeners.forEach(updateListener);\r\n        return children;\r\n    };\r\n    const Consumer = (props, children) => {\r\n        // The casting on subscribe is to allow for crossover through the stencil compiler\r\n        // In the future we should allow for generics in components.\r\n        return consumerRender(subscribe, children[0]);\r\n    };\r\n    const injectProps = (Cstr, fieldList) => {\r\n        const CstrPrototype = Cstr.prototype;\r\n        const cstrConnectedCallback = CstrPrototype.connectedCallback;\r\n        const cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;\r\n        CstrPrototype.connectedCallback = function () {\r\n            subscribe(this, fieldList);\r\n            if (cstrConnectedCallback) {\r\n                return cstrConnectedCallback.call(this);\r\n            }\r\n        };\r\n        CstrPrototype.disconnectedCallback = function () {\r\n            listeners.delete(this);\r\n            if (cstrDisconnectedCallback) {\r\n                cstrDisconnectedCallback.call(this);\r\n            }\r\n        };\r\n    };\r\n    return {\r\n        Provider,\r\n        Consumer,\r\n        injectProps\r\n    };\r\n};\n\nconst ActiveRouter = createProviderConsumer({\r\n    historyType: 'browser',\r\n    location: {\r\n        pathname: '',\r\n        query: {},\r\n        key: ''\r\n    },\r\n    titleSuffix: '',\r\n    root: '/',\r\n    routeViewsUpdated: () => { }\r\n}, (subscribe, child) => (h(\"context-consumer\", { subscribe: subscribe, renderer: child })));\n\nexport { ActiveRouter as A };\n","/**\r\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\r\n */\r\n/**\r\n * Default configs.\r\n */\r\nconst DEFAULT_DELIMITER = '/';\r\nconst DEFAULT_DELIMITERS = './';\r\n/**\r\n * The main path matching regexp utility.\r\n */\r\nconst PATH_REGEXP = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\r\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\r\n].join('|'), 'g');\r\n/**\r\n * Parse a string for the raw tokens.\r\n */\r\nconst parse = (str, options) => {\r\n    var tokens = [];\r\n    var key = 0;\r\n    var index = 0;\r\n    var path = '';\r\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\r\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\r\n    var pathEscaped = false;\r\n    var res;\r\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\r\n        var m = res[0];\r\n        var escaped = res[1];\r\n        var offset = res.index;\r\n        path += str.slice(index, offset);\r\n        index = offset + m.length;\r\n        // Ignore already escaped sequences.\r\n        if (escaped) {\r\n            path += escaped[1];\r\n            pathEscaped = true;\r\n            continue;\r\n        }\r\n        var prev = '';\r\n        var next = str[index];\r\n        var name = res[2];\r\n        var capture = res[3];\r\n        var group = res[4];\r\n        var modifier = res[5];\r\n        if (!pathEscaped && path.length) {\r\n            var k = path.length - 1;\r\n            if (delimiters.indexOf(path[k]) > -1) {\r\n                prev = path[k];\r\n                path = path.slice(0, k);\r\n            }\r\n        }\r\n        // Push the current path onto the tokens.\r\n        if (path) {\r\n            tokens.push(path);\r\n            path = '';\r\n            pathEscaped = false;\r\n        }\r\n        var partial = prev !== '' && next !== undefined && next !== prev;\r\n        var repeat = modifier === '+' || modifier === '*';\r\n        var optional = modifier === '?' || modifier === '*';\r\n        var delimiter = prev || defaultDelimiter;\r\n        var pattern = capture || group;\r\n        tokens.push({\r\n            name: name || key++,\r\n            prefix: prev,\r\n            delimiter: delimiter,\r\n            optional: optional,\r\n            repeat: repeat,\r\n            partial: partial,\r\n            pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\r\n        });\r\n    }\r\n    // Push any remaining characters.\r\n    if (path || index < str.length) {\r\n        tokens.push(path + str.substr(index));\r\n    }\r\n    return tokens;\r\n};\r\n/**\r\n * Escape a regular expression string.\r\n */\r\nconst escapeString = (str) => {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\r\n};\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n */\r\nconst escapeGroup = (group) => {\r\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\r\n};\r\n/**\r\n * Get the flags for a regexp from the options.\r\n */\r\nconst flags = (options) => {\r\n    return options && options.sensitive ? '' : 'i';\r\n};\r\n/**\r\n * Pull out keys from a regexp.\r\n */\r\nconst regexpToRegexp = (path, keys) => {\r\n    if (!keys)\r\n        return path;\r\n    // Use a negative lookahead to match only capturing groups.\r\n    var groups = path.source.match(/\\((?!\\?)/g);\r\n    if (groups) {\r\n        for (var i = 0; i < groups.length; i++) {\r\n            keys.push({\r\n                name: i,\r\n                prefix: null,\r\n                delimiter: null,\r\n                optional: false,\r\n                repeat: false,\r\n                partial: false,\r\n                pattern: null\r\n            });\r\n        }\r\n    }\r\n    return path;\r\n};\r\n/**\r\n * Transform an array into a regexp.\r\n */\r\nconst arrayToRegexp = (path, keys, options) => {\r\n    var parts = [];\r\n    for (var i = 0; i < path.length; i++) {\r\n        parts.push(pathToRegexp(path[i], keys, options).source);\r\n    }\r\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n};\r\n/**\r\n * Create a path regexp from string input.\r\n */\r\nconst stringToRegexp = (path, keys, options) => {\r\n    return tokensToRegExp(parse(path, options), keys, options);\r\n};\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n */\r\nconst tokensToRegExp = (tokens, keys, options) => {\r\n    options = options || {};\r\n    var strict = options.strict;\r\n    var end = options.end !== false;\r\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\r\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\r\n    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');\r\n    var route = '';\r\n    var isEndDelimited = false;\r\n    // Iterate over the tokens and create our regexp string.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            route += escapeString(token);\r\n            isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;\r\n        }\r\n        else {\r\n            var prefix = escapeString(token.prefix || '');\r\n            var capture = token.repeat\r\n                ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\r\n                : token.pattern;\r\n            if (keys)\r\n                keys.push(token);\r\n            if (token.optional) {\r\n                if (token.partial) {\r\n                    route += prefix + '(' + capture + ')?';\r\n                }\r\n                else {\r\n                    route += '(?:' + prefix + '(' + capture + '))?';\r\n                }\r\n            }\r\n            else {\r\n                route += prefix + '(' + capture + ')';\r\n            }\r\n        }\r\n    }\r\n    if (end) {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + ')?';\r\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\r\n    }\r\n    else {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\r\n        if (!isEndDelimited)\r\n            route += '(?=' + delimiter + '|' + endsWith + ')';\r\n    }\r\n    return new RegExp('^' + route, flags(options));\r\n};\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n */\r\nconst pathToRegexp = (path, keys, options) => {\r\n    if (path instanceof RegExp) {\r\n        return regexpToRegexp(path, keys);\r\n    }\r\n    if (Array.isArray(path)) {\r\n        return arrayToRegexp(path, keys, options);\r\n    }\r\n    return stringToRegexp(path, keys, options);\r\n};\n\nconst hasBasename = (path, prefix) => {\r\n    return (new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i')).test(path);\r\n};\r\nconst stripBasename = (path, prefix) => {\r\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\r\n};\r\nconst stripTrailingSlash = (path) => {\r\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\r\n};\r\nconst addLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path : '/' + path;\r\n};\r\nconst stripLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path.substr(1) : path;\r\n};\r\nconst parsePath = (path) => {\r\n    let pathname = path || '/';\r\n    let search = '';\r\n    let hash = '';\r\n    const hashIndex = pathname.indexOf('#');\r\n    if (hashIndex !== -1) {\r\n        hash = pathname.substr(hashIndex);\r\n        pathname = pathname.substr(0, hashIndex);\r\n    }\r\n    const searchIndex = pathname.indexOf('?');\r\n    if (searchIndex !== -1) {\r\n        search = pathname.substr(searchIndex);\r\n        pathname = pathname.substr(0, searchIndex);\r\n    }\r\n    return {\r\n        pathname,\r\n        search: search === '?' ? '' : search,\r\n        hash: hash === '#' ? '' : hash,\r\n        query: {},\r\n        key: ''\r\n    };\r\n};\r\nconst createPath = (location) => {\r\n    const { pathname, search, hash } = location;\r\n    let path = pathname || '/';\r\n    if (search && search !== '?') {\r\n        path += (search.charAt(0) === '?' ? search : `?${search}`);\r\n    }\r\n    if (hash && hash !== '#') {\r\n        path += (hash.charAt(0) === '#' ? hash : `#${hash}`);\r\n    }\r\n    return path;\r\n};\r\nconst parseQueryString = (query) => {\r\n    if (!query) {\r\n        return {};\r\n    }\r\n    return (/^[?#]/.test(query) ? query.slice(1) : query)\r\n        .split('&')\r\n        .reduce((params, param) => {\r\n        let [key, value] = param.split('=');\r\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\r\n        return params;\r\n    }, {});\r\n};\n\nconst isAbsolute = (pathname) => {\r\n    return pathname.charAt(0) === '/';\r\n};\r\nconst createKey = (keyLength) => {\r\n    return Math.random().toString(36).substr(2, keyLength);\r\n};\r\n// About 1.5x faster than the two-arg version of Array#splice()\r\nconst spliceOne = (list, index) => {\r\n    for (let i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\r\n        list[i] = list[k];\r\n    }\r\n    list.pop();\r\n};\r\n// This implementation is based heavily on node's url.parse\r\nconst resolvePathname = (to, from = '') => {\r\n    let fromParts = from && from.split('/') || [];\r\n    let hasTrailingSlash;\r\n    let up = 0;\r\n    const toParts = to && to.split('/') || [];\r\n    const isToAbs = to && isAbsolute(to);\r\n    const isFromAbs = from && isAbsolute(from);\r\n    const mustEndAbs = isToAbs || isFromAbs;\r\n    if (to && isAbsolute(to)) {\r\n        // to is absolute\r\n        fromParts = toParts;\r\n    }\r\n    else if (toParts.length) {\r\n        // to is relative, drop the filename\r\n        fromParts.pop();\r\n        fromParts = fromParts.concat(toParts);\r\n    }\r\n    if (!fromParts.length) {\r\n        return '/';\r\n    }\r\n    if (fromParts.length) {\r\n        const last = fromParts[fromParts.length - 1];\r\n        hasTrailingSlash = (last === '.' || last === '..' || last === '');\r\n    }\r\n    else {\r\n        hasTrailingSlash = false;\r\n    }\r\n    for (let i = fromParts.length; i >= 0; i--) {\r\n        const part = fromParts[i];\r\n        if (part === '.') {\r\n            spliceOne(fromParts, i);\r\n        }\r\n        else if (part === '..') {\r\n            spliceOne(fromParts, i);\r\n            up++;\r\n        }\r\n        else if (up) {\r\n            spliceOne(fromParts, i);\r\n            up--;\r\n        }\r\n    }\r\n    if (!mustEndAbs) {\r\n        for (; up--; up) {\r\n            fromParts.unshift('..');\r\n        }\r\n    }\r\n    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {\r\n        fromParts.unshift('');\r\n    }\r\n    let result = fromParts.join('/');\r\n    if (hasTrailingSlash && result.substr(-1) !== '/') {\r\n        result += '/';\r\n    }\r\n    return result;\r\n};\r\nconst valueEqual = (a, b) => {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(a)) {\r\n        return Array.isArray(b) && a.length === b.length && a.every((item, index) => {\r\n            return valueEqual(item, b[index]);\r\n        });\r\n    }\r\n    const aType = typeof a;\r\n    const bType = typeof b;\r\n    if (aType !== bType) {\r\n        return false;\r\n    }\r\n    if (aType === 'object') {\r\n        const aValue = a.valueOf();\r\n        const bValue = b.valueOf();\r\n        if (aValue !== a || bValue !== b) {\r\n            return valueEqual(aValue, bValue);\r\n        }\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        if (aKeys.length !== bKeys.length) {\r\n            return false;\r\n        }\r\n        return aKeys.every((key) => {\r\n            return valueEqual(a[key], b[key]);\r\n        });\r\n    }\r\n    return false;\r\n};\r\nconst locationsAreEqual = (a, b) => {\r\n    return a.pathname === b.pathname &&\r\n        a.search === b.search &&\r\n        a.hash === b.hash &&\r\n        a.key === b.key &&\r\n        valueEqual(a.state, b.state);\r\n};\r\nconst createLocation = (path, state, key, currentLocation) => {\r\n    let location;\r\n    if (typeof path === 'string') {\r\n        // Two-arg form: push(path, state)\r\n        location = parsePath(path);\r\n        if (state !== undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    else {\r\n        // One-arg form: push(location)\r\n        location = Object.assign({ pathname: '' }, path);\r\n        if (location.search && location.search.charAt(0) !== '?') {\r\n            location.search = '?' + location.search;\r\n        }\r\n        if (location.hash && location.hash.charAt(0) !== '#') {\r\n            location.hash = '#' + location.hash;\r\n        }\r\n        if (state !== undefined && location.state === undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    try {\r\n        location.pathname = decodeURI(location.pathname);\r\n    }\r\n    catch (e) {\r\n        if (e instanceof URIError) {\r\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' +\r\n                'This is likely caused by an invalid percent-encoding.');\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    location.key = key;\r\n    if (currentLocation) {\r\n        // Resolve incomplete/relative pathname relative to current location.\r\n        if (!location.pathname) {\r\n            location.pathname = currentLocation.pathname;\r\n        }\r\n        else if (location.pathname.charAt(0) !== '/') {\r\n            location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\r\n        }\r\n    }\r\n    else {\r\n        // When there is no prior location and pathname is empty, set it to /\r\n        if (!location.pathname) {\r\n            location.pathname = '/';\r\n        }\r\n    }\r\n    location.query = parseQueryString(location.search || '');\r\n    return location;\r\n};\n\nlet cacheCount = 0;\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\n// Memoized function for creating the path match regex\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n    const cachePattern = JSON.stringify(pattern);\r\n    if (cache[cachePattern]) {\r\n        return cache[cachePattern];\r\n    }\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n    if (cacheCount < cacheLimit) {\r\n        cache[cachePattern] = compiledPattern;\r\n        cacheCount += 1;\r\n    }\r\n    return compiledPattern;\r\n};\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nconst matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options };\r\n    }\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n    return {\r\n        path,\r\n        url: path === '/' && url === '' ? '/' : url,\r\n        isExact,\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {})\r\n    };\r\n};\r\nconst matchesAreEqual = (a, b) => {\r\n    if (a == null && b == null) {\r\n        return true;\r\n    }\r\n    if (b == null) {\r\n        return false;\r\n    }\r\n    return a && b &&\r\n        a.path === b.path &&\r\n        a.url === b.url &&\r\n        valueEqual(a.params, b.params);\r\n};\n\nconst getConfirmation = (win, message, callback) => (callback(win.confirm(message)));\r\nconst isModifiedEvent = (ev) => (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey);\r\n/**\r\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\r\n *\r\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\r\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\r\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\r\n */\r\nconst supportsHistory = (win) => {\r\n    const ua = win.navigator.userAgent;\r\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\r\n        ua.indexOf('Mobile Safari') !== -1 &&\r\n        ua.indexOf('Chrome') === -1 &&\r\n        ua.indexOf('Windows Phone') === -1) {\r\n        return false;\r\n    }\r\n    return win.history && 'pushState' in win.history;\r\n};\r\n/**\r\n * Returns true if browser fires popstate on hash change.\r\n * IE10 and IE11 do not.\r\n */\r\nconst supportsPopStateOnHashChange = (nav) => (nav.userAgent.indexOf('Trident') === -1);\r\n/**\r\n * Returns false if using go(n) with hash history causes a full page reload.\r\n */\r\nconst supportsGoWithoutReloadUsingHash = (nav) => (nav.userAgent.indexOf('Firefox') === -1);\r\nconst isExtraneousPopstateEvent = (nav, event) => (event.state === undefined &&\r\n    nav.userAgent.indexOf('CriOS') === -1);\r\nconst storageAvailable = (win, type) => {\r\n    const storage = win[type];\r\n    const x = '__storage_test__';\r\n    try {\r\n        storage.setItem(x, x);\r\n        storage.removeItem(x);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return e instanceof DOMException && (\r\n        // everything except Firefox\r\n        e.code === 22 ||\r\n            // Firefox\r\n            e.code === 1014 ||\r\n            // test name field too, because code might not be present\r\n            // everything except Firefox\r\n            e.name === 'QuotaExceededError' ||\r\n            // Firefox\r\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n            // acknowledge QuotaExceededError only if there's something already stored\r\n            storage.length !== 0;\r\n    }\r\n};\n\nexport { matchesAreEqual as a, supportsHistory as b, supportsPopStateOnHashChange as c, stripTrailingSlash as d, addLeadingSlash as e, createLocation as f, createKey as g, hasBasename as h, stripBasename as i, createPath as j, getConfirmation as k, isExtraneousPopstateEvent as l, matchPath as m, supportsGoWithoutReloadUsingHash as n, stripLeadingSlash as o, locationsAreEqual as p, isModifiedEvent as q, storageAvailable as s };\n"],"names":["ActiveRouter","defaultState","consumerRender","listeners","Map","currentState","updateListener","fields","instance","Array","isArray","_toConsumableArray","forEach","fieldName","Object","assign","subscribe","propList","has","set","delete","Provider","_ref","children","state","Consumer","props","injectProps","Cstr","fieldList","CstrPrototype","prototype","cstrConnectedCallback","connectedCallback","cstrDisconnectedCallback","disconnectedCallback","this","call","createProviderConsumer","historyType","location","pathname","query","key","titleSuffix","root","routeViewsUpdated","child","h","renderer","PATH_REGEXP","RegExp","join","escapeString","str","replace","escapeGroup","group","flags","options","sensitive","arrayToRegexp","path","keys","parts","i","length","push","pathToRegexp","source","stringToRegexp","tokensToRegExp","res","tokens","index","defaultDelimiter","delimiter","delimiters","pathEscaped","exec","m","escaped","offset","slice","prev","next","name","capture","modifier","k","indexOf","partial","undefined","repeat","optional","pattern","prefix","substr","parse","strict","end","endsWith","concat","map","route","isEndDelimited","token","groups","match","regexpToRegexp","hasBasename","test","stripBasename","stripTrailingSlash","charAt","addLeadingSlash","stripLeadingSlash","createPath","search","hash","isAbsolute","createKey","keyLength","Math","random","toString","spliceOne","list","n","pop","valueEqual","a","b","every","item","aType","aValue","valueOf","bValue","aKeys","bKeys","locationsAreEqual","createLocation","currentLocation","hashIndex","searchIndex","parsePath","decodeURI","e","URIError","to","hasTrailingSlash","from","arguments","fromParts","split","up","toParts","isToAbs","isFromAbs","mustEndAbs","last","part","unshift","result","resolvePathname","reduce","params","param","_param$split","_param$split2","_slicedToArray","value","decodeURIComponent","cacheCount","patternCache","matchPath","_options","_options$path","_options$exact","exact","_options$strict","_compilePath","cacheKey","cache","cachePattern","JSON","stringify","compiledPattern","re","compilePath","_match","_toArray","url","values","isExact","memo","matchesAreEqual","getConfirmation","win","message","callback","confirm","isModifiedEvent","ev","metaKey","altKey","ctrlKey","shiftKey","supportsHistory","ua","navigator","userAgent","history","supportsPopStateOnHashChange","nav","supportsGoWithoutReloadUsingHash","isExtraneousPopstateEvent","event","storageAvailable","type","storage","x","setItem","removeItem","DOMException","code"],"sourceRoot":""}