{"version":3,"file":"static/js/6579.2dd97599.chunk.js","mappings":"iTAEMA,EAAQ,EACRC,EAAQ,IACRC,EAAQ,IAAIC,KAAK,IAAM,EAAG,EAAG,EAAG,GAChCC,EAAQ,IAAID,KAAK,IAAM,EAAG,EAAG,EAAG,IAChCE,EAAU,KACVC,EAAiB,UAEZ,IAAIH,KAAKD,EAAMK,UAAa,EAAI,GAAMH,EAAMG,UAAYL,EAAMK,YAUzE,IAAMC,EAA2B,CAC7BC,GAAIP,EAAMK,UAAYH,EAAMG,WAAa,EACzCG,EAAGL,E,4HCdDM,GAAgBC,E,QAAAA,IAAS,SAACC,GAAC,OAAKA,EAAEJ,CAAC,IAenCK,EAAiB,SAACC,EAAMC,GAIG,IAAjCC,IAAqBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACXG,GAAQC,EAAAA,EAAAA,GAAwBN,GAChC,IAAIb,KAAKa,EAASK,OAClB,IAAIlB,KAAKA,KAAKoB,OAAQC,EAAAA,EAAAA,GAAcR,EAASS,WAC7CC,GAAMJ,EAAAA,EAAAA,GAAwBN,GAAY,IAAIb,KAAKa,EAASU,KAAO,IAAIvB,KAE7E,GAAoB,IAAhBY,EAAKI,OACL,MAAO,GAGX,GAAIE,EAAMd,UAAYQ,EAAKA,EAAKI,OAAS,GAAGV,EACxC,MAAO,GAGX,GAAIiB,EAAInB,UAAYQ,EAAK,GAAGN,EACxB,MAAO,GAIX,IAAMkB,EAAaC,KAAKC,IAAIlB,EAAcmB,KAAKf,EAAMM,IAAUJ,EAAwB,EAAI,GAAI,GACzFc,EAAWH,KAAKI,IAAIrB,EAAcsB,MAAMlB,EAAMW,IAAQT,EAAwB,EAAI,GAAIF,EAAKI,OAAS,GAC1G,OAAOJ,EAAKmB,MAAMP,EAAYI,EAAW,EAC7C,EAMMI,EAAoB,SAACpB,EAAMqB,GAE7B,GAAoB,IAAhBrB,EAAKI,OACL,MAAO,GAGX,GAAIiB,EAAK7B,UAAYQ,EAAK,GAAGN,EACzB,MAAO,GAIX,IAAMsB,EAAWH,KAAKI,IAAIrB,EAAcsB,MAAMlB,EAAMqB,GAAQ,EAAGrB,EAAKI,OAAS,GAC7E,OAAOJ,EAAKmB,MAAM,EAAGH,EAAW,EACpC,C,2KCvDMM,G,8BAAuB,WAC3B,SAAAA,EAAYC,IAASC,EAAAA,EAAAA,GAAA,KAAAF,IACnBG,EAAAA,EAAAA,GAAiBC,KAAMH,EACzB,CAkBC,OAlBAI,EAAAA,EAAAA,GAAAL,EAAA,EAAAM,IAAA,SAAAC,MACD,WACE,OAAQC,EAAAA,EAAAA,GAAE,MAAO,MAAMA,EAAAA,EAAAA,GAAE,eAAgB,CAAEC,YAAa,CACpD,CACEC,GAAI,OACJC,MAAO,QACPC,KAAM,cACNlC,KAAM,GACNmC,YAAUC,EAAAA,EAAAA,GAAA,GACPC,EAAAA,EAAe,CAAC5C,EAAAA,IAEnB6C,WAAYD,EAAAA,EACZE,SAAUC,EAAAA,EAASC,SAEpBC,SAAU,UAAWC,KAAM,CAC5BC,MAAO,IACPC,OAAQ,KACP5C,SAAU,CAAE6C,KAAM7D,EAAAA,EAAO8D,KAAM7D,EAAAA,EAAOoB,MAAOnB,EAAAA,EAAOwB,IAAKtB,EAAAA,MAAYyC,EAAAA,EAAAA,GAAE,mBAAoB,MAClG,KAACR,CAAA,CArB0B,G","sources":["../node_modules/@iot-app-kit/components/dist/esm/constants-8fe8bb38.js","../node_modules/@iot-app-kit/components/dist/esm/dataFilters-fa384f64.js","../node_modules/@iot-app-kit/components/dist/esm/sc-webgl-bar-chart-standard.entry.js"],"sourcesContent":["import './constants-9d5458e0.js';\n\nconst Y_MIN = 0;\nconst Y_MAX = 5000;\nconst X_MIN = new Date(2000, 0, 0, 0, 0);\nconst X_MAX = new Date(2000, 0, 0, 0, 10);\nconst Y_VALUE = 2500;\nconst Y_VALUE_STRING = 'Warning';\n({\n    value: new Date(X_MIN.getTime() + (1 / 3) * (X_MAX.getTime() - X_MIN.getTime())),\n    label: {\n        text: 'here is a x label',\n        show: true,\n    },\n    showValue: true,\n    color: 'purple',\n    id: 'purple-x-annotation',\n});\n// test data point dead center of the viewport\nconst TEST_DATA_POINT_STANDARD = {\n    x: (X_MIN.getTime() + X_MAX.getTime()) / 2,\n    y: Y_VALUE,\n};\n\nexport { TEST_DATA_POINT_STANDARD as T, X_MIN as X, Y_VALUE_STRING as Y, Y_VALUE as a, Y_MIN as b, Y_MAX as c, X_MAX as d };\n","import { a as isMinimalStaticViewport } from './predicates-248e16b2.js';\nimport { p as parseDuration } from './time-b684d8c5.js';\nimport { b as bisector } from './bisector-ecf52045.js';\n\n// By doing the mapping to a date within the bisector\n// we eliminate the need to iterate over the entire data.\n// (As opposed to mapping entire data to an array of dates)\nconst pointBisector = bisector((p) => p.x);\n/**\n * Get Visible Data\n *\n * Returns the data points which are required for the chart to correctly render.\n * This assumes linear interpolation between points\n * TODO: Support other interpolation methods\n *\n * NOTE: It's possible to have data not in the viewport which is required for the chart to render\n * it's fully visualization correctly. For Instance, even if a point isn't visible in the viewport, it may\n * be used within interpolation to calculate a path between the points which is within the viewport.\n *\n * Different interpolation methods need larger amount of context around the viewport to correctly render\n * the chart visualization.\n */\nconst getVisibleData = (data, viewport, \n// Whether we want to include a single point to the right, and to the left of the provide viewport.\n// This is useful when rendering lines since you need to connect a point to a point outside of the viewport\n// to fully render the data correctly.\nincludeBoundaryPoints = true) => {\n    const start = isMinimalStaticViewport(viewport)\n        ? new Date(viewport.start)\n        : new Date(Date.now() - parseDuration(viewport.duration));\n    const end = isMinimalStaticViewport(viewport) ? new Date(viewport.end) : new Date();\n    // If there is no data\n    if (data.length === 0) {\n        return [];\n    }\n    // If all data is before the view port\n    if (start.getTime() > data[data.length - 1].x) {\n        return [];\n    }\n    // If all data is after the view port\n    if (end.getTime() < data[0].x) {\n        return [];\n    }\n    // Otherwise return all the data within the viewport, plus an additional single data point that falls outside of\n    // the viewport in either direction.\n    const startIndex = Math.max(pointBisector.left(data, start) - (includeBoundaryPoints ? 1 : 0), 0);\n    const endIndex = Math.min(pointBisector.right(data, end) - (includeBoundaryPoints ? 0 : 1), data.length - 1);\n    return data.slice(startIndex, endIndex + 1);\n};\n/**\n * Returns all data before or at the given date.\n *\n * Assumes data is ordered chronologically.\n */\nconst getDataBeforeDate = (data, date) => {\n    // If there is no data\n    if (data.length === 0) {\n        return [];\n    }\n    // If all data is after the view port\n    if (date.getTime() < data[0].x) {\n        return [];\n    }\n    // Otherwise return all the data within the viewport, plus an additional single data point that falls outside of\n    // the viewport in either direction.\n    const endIndex = Math.min(pointBisector.right(data, date) - 1, data.length - 1);\n    return data.slice(0, endIndex + 1);\n};\n\nexport { getVisibleData as a, getDataBeforeDate as g, pointBisector as p };\n","import { r as registerInstance, h } from './index-1cec361c.js';\nimport { M as MINUTE_IN_MS } from './time-b684d8c5.js';\nimport { T as TEST_DATA_POINT_STANDARD, b as Y_MIN, c as Y_MAX, X as X_MIN, d as X_MAX } from './constants-8fe8bb38.js';\nimport './constants-9d5458e0.js';\nimport { D as DataType } from './dataConstants-71f11842.js';\nimport './utils-0919edc8.js';\nimport './dataFilters-fa384f64.js';\nimport './index-b3f1c3a1.js';\nimport './predicates-248e16b2.js';\nimport './number-3e8376bf.js';\nimport './bisector-ecf52045.js';\n\nconst ScWebglBarChartStandard = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n  }\n  render() {\n    return (h(\"div\", null, h(\"sc-bar-chart\", { dataStreams: [\n        {\n          id: 'test',\n          color: 'black',\n          name: 'test stream',\n          data: [],\n          aggregates: {\n            [MINUTE_IN_MS]: [TEST_DATA_POINT_STANDARD],\n          },\n          resolution: MINUTE_IN_MS,\n          dataType: DataType.NUMBER,\n        },\n      ], widgetId: \"test-id\", size: {\n        width: 500,\n        height: 500,\n      }, viewport: { yMin: Y_MIN, yMax: Y_MAX, start: X_MIN, end: X_MAX } }), h(\"sc-webgl-context\", null)));\n  }\n};\n\nexport { ScWebglBarChartStandard as sc_webgl_bar_chart_standard };\n"],"names":["Y_MIN","Y_MAX","X_MIN","Date","X_MAX","Y_VALUE","Y_VALUE_STRING","getTime","TEST_DATA_POINT_STANDARD","x","y","pointBisector","bisector","p","getVisibleData","data","viewport","includeBoundaryPoints","arguments","length","undefined","start","isMinimalStaticViewport","now","parseDuration","duration","end","startIndex","Math","max","left","endIndex","min","right","slice","getDataBeforeDate","date","ScWebglBarChartStandard","hostRef","_classCallCheck","registerInstance","this","_createClass","key","value","h","dataStreams","id","color","name","aggregates","_defineProperty","MINUTE_IN_MS","resolution","dataType","DataType","NUMBER","widgetId","size","width","height","yMin","yMax"],"sourceRoot":""}