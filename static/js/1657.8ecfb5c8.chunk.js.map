{"version":3,"file":"static/js/1657.8ecfb5c8.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/chartDefaults-eb37c77e.js","../node_modules/@iot-app-kit/components/dist/esm/pointMesh-7ba3f14f.js","../node_modules/@iot-app-kit/components/dist/esm/sc-scatter-chart.entry.js","../node_modules/@iot-app-kit/components/dist/esm/validate-4270e546.js"],"sourcesContent":["import { b as ScaleType, L as LEGEND_POSITION } from './constants-9d5458e0.js';\n\nconst DEFAULT_CHART_CONFIG = {\n    widgetId: 'fake-id',\n    viewport: {\n        start: new Date(1995, 0, 0, 0),\n        end: new Date(2020, 1, 0, 0),\n        yMin: 0,\n        yMax: 10000,\n    },\n    // width is width - marginLeft - marginRight\n    size: { width: 400 + 50 + 25, height: 350, marginLeft: 50, marginRight: 50, marginTop: 24, marginBottom: 30 },\n    movement: {\n        enableXScroll: true,\n        enableYScroll: false,\n        zoomMax: Infinity,\n        zoomMin: 0.00001,\n    },\n    layout: {\n        xGridVisible: false,\n        yGridVisible: true,\n        xTicksVisible: true,\n        yTicksVisible: true,\n    },\n    scale: {\n        xScaleType: ScaleType.TimeSeries,\n        yScaleType: ScaleType.Linear,\n        xScaleSide: 'bottom',\n        yScaleSide: 'left',\n    },\n    dataStreams: [],\n    legend: {\n        position: LEGEND_POSITION.BOTTOM,\n        width: 170,\n    },\n};\nconst DEFAULT_THRESHOLD_OPTIONS = {\n    showColor: true,\n};\nconst DEFAULT_THRESHOLD_OPTIONS_OFF = {\n    showColor: false,\n};\n\nexport { DEFAULT_CHART_CONFIG as D, DEFAULT_THRESHOLD_OPTIONS as a, DEFAULT_THRESHOLD_OPTIONS_OFF as b };\n","import { c as BufferGeometry, d as ShaderMaterial, P as Points, B as BufferAttribute } from './three.module-8c8bcb27.js';\nimport { g as getCSSColorByString, n as numDataPoints, v as vertices } from './clipSpaceConversion-9fa25666.js';\nimport { a as getNumberThresholds, s as sortThreshold, g as getBreachedThreshold } from './utils-0919edc8.js';\nimport { C as COMPARISON_OPERATOR } from './constants-9d5458e0.js';\nimport { b as isNumberDataStream } from './predicates-248e16b2.js';\n\nconst pointVert = (showColor) => `\nvarying vec3 vColor;\n${showColor ? 'varying float positionY;' : ''}\nattribute vec3 pointColor;\nuniform float pointDiameter;\nuniform float devicePixelRatio;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x, position.y, 0.0, 1.0);\n  gl_PointSize = pointDiameter * devicePixelRatio;\n  vColor = pointColor;\n  ${showColor ? 'positionY = position.y;' : ''}\n}\n`;\n\nconst shaderFrag = `\nvarying vec3 vColor;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n  gl_FragColor = vec4(vColor, alpha);\n}\n`;\n\n/**\n * Max of 13 threshold bands because we allow only up to 12 thresholds. Imaging a piece of paper being split into\n * 12 times. You will end up with 13 different pieces.\n */\nconst MAX_THRESHOLD_BANDS = 13;\n/**\n * First we sort the thresholds then reverse it. Reversing the sorted threshold allows us to create the band from\n * top to bottom.\n *\n * For each threshold that is not the first or the last, we check both upper and lower to see if a band is needed.\n *\n * Because we check against the previous threshold and the next threshold, a set is needed to prevent duplicates\n *\n * We know that all the threshold bands can only have unique upper, so we will be using that as the key in the Set.\n */\nconst thresholdBands = (thresholds) => {\n    if (thresholds.length === 0) {\n        return [];\n    }\n    const numberThresholds = getNumberThresholds(thresholds);\n    const sortedThresholds = sortThreshold(numberThresholds).reverse();\n    const bands = [];\n    const thresholdBandsSet = new Set();\n    sortedThresholds.forEach((threshold, index) => {\n        const thresholdValue = threshold.value;\n        if (sortedThresholds[index].comparisonOperator === COMPARISON_OPERATOR.EQUAL) {\n            const [r, g, b] = getCSSColorByString(sortedThresholds[index].color);\n            bands.push({\n                upper: thresholdValue,\n                lower: thresholdValue,\n                color: [r, g, b],\n            });\n            return;\n        }\n        /**\n         * When looking at the first threshold, we want to find a mid point between the MAX SAFE INTEGER and the first\n         * threshold value to determine if the first threshold is an upper bound threshold.\n         */\n        if (index === 0) {\n            const midPoint = (Number.MAX_SAFE_INTEGER + thresholdValue) / 2;\n            const breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n            if (breachedThreshold != null) {\n                const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n                bands.push({\n                    upper: Number.MAX_SAFE_INTEGER,\n                    lower: thresholdValue,\n                    color: [r, g, b],\n                });\n            }\n            return;\n        }\n        /**\n         * When looking at the thresholds that is not the first or the last, we want to compare it with the one before\n         * to make sure if there is an upper band or not.\n         */\n        const prevThreshold = sortedThresholds[index - 1];\n        const prevThresholdValue = prevThreshold.value;\n        let midPoint = (prevThresholdValue + thresholdValue) / 2;\n        let breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n        if (breachedThreshold != null) {\n            if (!thresholdBandsSet.has(prevThreshold.value)) {\n                const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n                if (prevThreshold.comparisonOperator === COMPARISON_OPERATOR.EQUAL &&\n                    prevThreshold.value === sortedThresholds[index].value) {\n                    bands.push({\n                        upper: prevThresholdValue,\n                        lower: thresholdValue,\n                        color: [r, g, b],\n                    });\n                }\n                else {\n                    bands.push({\n                        upper: prevThresholdValue,\n                        lower: thresholdValue,\n                        color: [r, g, b],\n                    });\n                }\n                thresholdBandsSet.add(prevThreshold.value);\n            }\n        }\n        /**\n         * When looking at the last threshold, we want to find the mid point between it and the Min Safe Int\n         * to see if there is a lower band that needs to be create.\n         */\n        if (index === sortedThresholds.length - 1) {\n            midPoint = (thresholdValue + Number.MIN_SAFE_INTEGER) / 2;\n            breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n            if (breachedThreshold != null && !thresholdBandsSet.has(thresholdValue)) {\n                const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n                bands.push({\n                    lower: Number.MIN_SAFE_INTEGER,\n                    upper: thresholdValue,\n                    color: [r, g, b],\n                });\n            }\n            return;\n        }\n        /**\n         * When looking at a threshold that is not first or last, we want to compare it with the next one to see if\n         * a lower band is needed.\n         */\n        const nexThreshold = sortedThresholds[index + 1];\n        const nexThresholdValue = nexThreshold.value;\n        midPoint = (thresholdValue + nexThresholdValue) / 2;\n        breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n        if (breachedThreshold != null && !thresholdBandsSet.has(thresholdValue)) {\n            const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n            bands.push({\n                upper: thresholdValue,\n                lower: nexThresholdValue,\n                color: [r, g, b],\n            });\n            thresholdBandsSet.add(threshold.value);\n        }\n    });\n    /**\n     * Because we need to have a set amount of buffer in Frag, which is 12. If the array length is not 12,\n     * we need to fill in the rest with proper threshold bands. It should be duplicates of the last threshold band\n     *\n     * This function also takes into account when there is only 1 threshold with lower bound.\n     */\n    let lastThresholdBand = bands[bands.length - 1];\n    while (bands.length < MAX_THRESHOLD_BANDS) {\n        const threshold = sortedThresholds[sortedThresholds.length - 1];\n        const thresholdValue = threshold.value;\n        const midPoint = Number.MIN_SAFE_INTEGER + thresholdValue / 2;\n        const breachedThreshold = getBreachedThreshold(midPoint, sortedThresholds);\n        if (breachedThreshold == null) {\n            bands.push(lastThresholdBand);\n        }\n        else {\n            const [r, g, b] = getCSSColorByString(breachedThreshold.color);\n            lastThresholdBand = {\n                lower: Number.MIN_SAFE_INTEGER,\n                upper: thresholdValue,\n                color: [r, g, b],\n            };\n            bands.push(lastThresholdBand);\n        }\n    }\n    return bands;\n};\n\nconst colorationShaderFrag = `\n#define MAX_NUM_TOTAL_THRESHOLD_BAND ${MAX_THRESHOLD_BANDS}\n\nstruct Band {\n  float upper;\n  float lower;\n  vec3 color;\n};\n\nvarying vec3 vColor;\nvarying float positionY;\n\nuniform Band thresholdBands[MAX_NUM_TOTAL_THRESHOLD_BAND];\nuniform float yPixelDensity;\n\nvoid main() {\n  // calculate position such that the center is (0, 0) in a region of [-1, 1] x [-1, 1]\n  vec2 pos = 2.0 * gl_PointCoord.xy - 1.0;\n  // r = distance squared from the origin of the point being rendered\n  float r = dot(pos, pos);\n  if (r > 1.0) {\n    discard;\n  }\n  float alpha = 1.0 - smoothstep(0.5, 1.0, sqrt(r));\n\n  for(int i = 0; i < MAX_NUM_TOTAL_THRESHOLD_BAND; i++) {\n    bool isRangeBreached = positionY >= thresholdBands[i].lower && positionY <= thresholdBands[i].upper;\n    bool isEqualsThreshold = thresholdBands[i].lower == thresholdBands[i].upper;\n    bool isEqualsThresholdBreached = positionY == thresholdBands[i].upper;\n\n    if (isRangeBreached || (isEqualsThreshold && isEqualsThresholdBreached)) {\n       gl_FragColor = vec4(thresholdBands[i].color /255.0, alpha);\n       break;\n    } else {\n       gl_FragColor = vec4(vColor, alpha);\n    }\n  }\n}\n`;\n\n/* eslint-disable no-param-reassign */\nconst POINT_MESH_INDEX = 0;\nconst POINT_DIAMETER = 6.25;\nconst RAW_POINT_DIAMETER = 4;\n/**\n * Get the diameter of the points to display on the chart.\n *\n * We want to display points smaller for raw data since they may be displayed very densely\n */\nconst pointDiameter = (dataStreams) => {\n    const resolution = dataStreams[0] != null ? dataStreams[0].resolution : null;\n    return resolution === 0 ? RAW_POINT_DIAMETER : POINT_DIAMETER;\n};\n/**\n * Create Point Mesh\n *\n * The representation of the points on a chart.\n */\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nconst NUM_POSITION_COMPONENTS = 2; // (x, y)\nconst NUM_COLOR_COMPONENTS = 3; // (r, g, b)\n/**\n * Update Geometry\n *\n * Updates the color, and position of the vertices sent down to the vertex shader.\n */\nconst updateGeometry = (geometry, dataStreams, toClipSpace) => {\n    const streamVertexSets = dataStreams.filter(isNumberDataStream).map(stream => vertices(stream, stream.resolution));\n    const allVertices = streamVertexSets.flat();\n    const { position, pointColor } = geometry.attributes;\n    /**\n     * Fill Buffers with data\n     */\n    allVertices.forEach(([x, y, r, g, b], i) => {\n        // Set Position\n        position.array[i * NUM_POSITION_COMPONENTS] = toClipSpace(x);\n        position.array[i * NUM_POSITION_COMPONENTS + 1] = y;\n        // Set Normal Data Stream Color\n        pointColor.array[i * NUM_COLOR_COMPONENTS] = r;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 1] = g;\n        pointColor.array[i * NUM_COLOR_COMPONENTS + 2] = b;\n    });\n    geometry.setDrawRange(0, allVertices.length);\n    position.needsUpdate = true;\n    pointColor.needsUpdate = true;\n};\nconst initializeGeometry = (geometry, bufferSize) => {\n    // TODO: Change to double precision\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('pointColor', new BufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\n/**\n * Create Point Mesh\n */\nconst pointMesh = ({ toClipSpace, dataStreams, minBufferSize, bufferFactor, thresholdOptions, thresholds, }) => {\n    const bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    const geometry = new BufferGeometry();\n    initializeGeometry(geometry, bufferSize);\n    updateGeometry(geometry, dataStreams, toClipSpace);\n    const { showColor = true } = thresholdOptions;\n    const material = new ShaderMaterial({\n        vertexShader: pointVert(showColor && thresholds.length > 0),\n        fragmentShader: !showColor || thresholds.length === 0 ? shaderFrag : colorationShaderFrag,\n        transparent: true,\n        uniforms: {\n            pointDiameter: {\n                value: pointDiameter(dataStreams),\n            },\n            devicePixelRatio: {\n                value: window.devicePixelRatio,\n            },\n            thresholdBands: {\n                value: thresholdBands(thresholds),\n            },\n        },\n    });\n    const points = new Points(geometry, material);\n    // Prevent computeBoundingSphere from being called\n    points.frustumCulled = false;\n    return points;\n};\n/**\n * Update Point Mesh\n *\n * Updates the point mesh to match the given data stream info and data streams.\n * Increases size of attribute buffers if necessary.\n */\nconst updatePointMesh = (dataStreams, points, toClipSpace, hasDataChanged = true) => {\n    /**\n     * Update Uniforms\n     *\n     * The uniforms are variables passed into the webgl Shaders.\n     * Learn more about uniforms:\n     * https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms\n     */\n    points.material.uniforms.pointDiameter.value = pointDiameter(dataStreams);\n    points.material.uniforms.devicePixelRatio.value = window.devicePixelRatio;\n    if (hasDataChanged) {\n        updateGeometry(points.geometry, dataStreams, toClipSpace);\n    }\n};\n\nexport { MAX_THRESHOLD_BANDS as M, NUM_POSITION_COMPONENTS as N, POINT_MESH_INDEX as P, pointMesh as p, thresholdBands as t, updatePointMesh as u };\n","import { r as registerInstance, h } from './index-1cec361c.js';\nimport { S as Scene } from './three.module-8c8bcb27.js';\nimport { P as POINT_MESH_INDEX, p as pointMesh, N as NUM_POSITION_COMPONENTS, u as updatePointMesh } from './pointMesh-7ba3f14f.js';\nimport { a as clipSpaceConversion, c as constructChartScene, n as numDataPoints, b as needsNewClipSpace } from './clipSpaceConversion-9fa25666.js';\nimport { a as getNumberThresholds } from './utils-0919edc8.js';\nimport { D as DEFAULT_CHART_CONFIG } from './chartDefaults-eb37c77e.js';\nimport { D as DATA_ALIGNMENT } from './constants-9d5458e0.js';\nimport { v as validate } from './validate-4270e546.js';\nimport { D as DataType } from './dataConstants-71f11842.js';\nimport './predicates-248e16b2.js';\nimport './v4-b6bb7e11.js';\nimport './_commonjsHelpers-f9dc4873.js';\nimport './getDataPoints-c53771e0.js';\nimport './index-42a9af88.js';\nimport './time-b684d8c5.js';\nimport './index-b3f1c3a1.js';\nimport './number-3e8376bf.js';\nimport './bisector-ecf52045.js';\n\nconst chartScene = ({ dataStreams, container, viewport, minBufferSize, bufferFactor, onUpdate, thresholdOptions, thresholds, }) => {\n    const scene = new Scene();\n    const toClipSpace = clipSpaceConversion(viewport);\n    const numberThresholds = getNumberThresholds(thresholds);\n    // Create and add meshes to the chart scene\n    const meshList = [];\n    meshList[POINT_MESH_INDEX] = pointMesh({\n        dataStreams,\n        minBufferSize,\n        bufferFactor,\n        toClipSpace,\n        thresholdOptions,\n        thresholds: numberThresholds,\n    });\n    meshList.forEach(mesh => scene.add(mesh));\n    return constructChartScene({ scene, viewport, container, toClipSpace, onUpdate });\n};\nconst maxDataPointsRendered = (points) => points.geometry.attributes.position.array.length / NUM_POSITION_COMPONENTS;\nconst updateChartScene = ({ scene, dataStreams, chartSize, container, viewport, hasDataChanged, bufferFactor, minBufferSize, onUpdate, thresholdOptions, thresholds, hasAnnotationChanged, }) => {\n    const points = scene.scene.children[POINT_MESH_INDEX];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    const isDataOverflowingBuffer = maxDataPointsRendered(points) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace) || hasAnnotationChanged) {\n        return chartScene({\n            dataStreams,\n            chartSize,\n            container,\n            viewport,\n            minBufferSize,\n            bufferFactor,\n            onUpdate,\n            thresholdOptions,\n            thresholds,\n        });\n    }\n    if (hasDataChanged) {\n        updatePointMesh(dataStreams, points, scene.toClipSpace);\n    }\n    // Return existing scene.\n    return scene;\n};\n\n// The initial size of buffers. The larger this is, the more memory allocated up front per chart.\n// The lower this number is, more likely that charts will have to re-initialize there buffers which is\n// a slow operation (CPU bound).\nconst DEFAULT_MIN_BUFFER_SIZE = 1000;\nconst DEFAULT_BUFFER_FACTOR = 2;\nconst tooltip = (props) => (h(\"sc-tooltip\", Object.assign({}, props, { visualizesAlarms: false, supportString: false, dataAlignment: DATA_ALIGNMENT.EITHER })));\nconst ScScatterChart = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.gestures = true;\n    /** Status */\n    this.isEditing = false;\n    /** Memory Management */\n    this.bufferFactor = DEFAULT_BUFFER_FACTOR;\n    this.minBufferSize = DEFAULT_MIN_BUFFER_SIZE;\n  }\n  componentWillRender() {\n    validate(this);\n  }\n  render() {\n    return (h(\"sc-size-provider\", { size: this.size, renderFunc: (rect) => (h(\"sc-webgl-base-chart\", { supportedDataTypes: [DataType.NUMBER], axis: this.axis, gestures: this.gestures, configId: this.widgetId, legend: this.legend, annotations: this.annotations, trends: this.trends, updateChartScene: updateChartScene, createChartScene: chartScene, size: Object.assign(Object.assign(Object.assign({}, DEFAULT_CHART_CONFIG.size), this.size), rect), dataStreams: this.dataStreams, alarms: this.alarms, viewport: this.viewport, minBufferSize: this.minBufferSize, bufferFactor: this.bufferFactor, isEditing: this.isEditing, renderTooltip: tooltip, supportString: false, visualizesAlarms: false, messageOverrides: this.messageOverrides })) }));\n  }\n};\n\nexport { ScScatterChart as sc_scatter_chart };\n","import { p as parse } from './index-b3f1c3a1.js';\nimport { a as isMinimalStaticViewport } from './predicates-248e16b2.js';\nimport { c as createCommonjsModule, a as getDefaultExportFromCjs } from './_commonjsHelpers-f9dc4873.js';\n\nvar assertString_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertString;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction assertString(input) {\n  var isString = typeof input === 'string' || input instanceof String;\n\n  if (!isString) {\n    var invalidType = _typeof(input);\n\n    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;\n    throw new TypeError(\"Expected a string but received a \".concat(invalidType));\n  }\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;\n});\n\nvar isISO8601_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isISO8601;\n\nvar _assertString = _interopRequireDefault(assertString_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable max-len */\n// from http://goo.gl/0ejHHW\nvar iso8601 = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/; // same as above, except with a strict 'T' separator between date and time\n\nvar iso8601StrictSeparator = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n/* eslint-enable max-len */\n\nvar isValidDate = function isValidDate(str) {\n  // str must have passed the ISO8601 check\n  // this check is meant to catch invalid dates\n  // like 2009-02-31\n  // first check for ordinal dates\n  var ordinalMatch = str.match(/^(\\d{4})-?(\\d{3})([ T]{1}\\.*|$)/);\n\n  if (ordinalMatch) {\n    var oYear = Number(ordinalMatch[1]);\n    var oDay = Number(ordinalMatch[2]); // if is leap year\n\n    if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;\n    return oDay <= 365;\n  }\n\n  var match = str.match(/(\\d{4})-?(\\d{0,2})-?(\\d*)/).map(Number);\n  var year = match[1];\n  var month = match[2];\n  var day = match[3];\n  var monthString = month ? \"0\".concat(month).slice(-2) : month;\n  var dayString = day ? \"0\".concat(day).slice(-2) : day; // create a date object and compare\n\n  var d = new Date(\"\".concat(year, \"-\").concat(monthString || '01', \"-\").concat(dayString || '01'));\n\n  if (month && day) {\n    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;\n  }\n\n  return true;\n};\n\nfunction isISO8601(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _assertString.default)(str);\n  var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);\n  if (check && options.strict) return isValidDate(str);\n  return check;\n}\n\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;\n});\n\nconst isISO8601 = /*@__PURE__*/getDefaultExportFromCjs(isISO8601_1);\n\nconst isValidDate = (date) => (date instanceof Date ? true : isISO8601(date));\n\nconst validate = ({ viewport }) => {\n    // skips if viewport is undefine\n    if (viewport != null) {\n        /**\n         * We cannot enforce the type that is coming in. So we throw and warn message if all\n         * start, end, and duration is being passed in.\n         */\n        if (isMinimalStaticViewport(viewport) && viewport.duration != null) {\n            // eslint-disable-next-line no-console\n            console.warn('Detected both static and live viewport type. Duration will be used');\n        }\n        if (isMinimalStaticViewport(viewport) && (!isValidDate(viewport.start) || !isValidDate(viewport.end))) {\n            throw new Error(`Unable to parse start date: '${viewport.start}' and/or end date: '${viewport.end}'`);\n        }\n        if (!isMinimalStaticViewport(viewport) &&\n            typeof viewport.duration === 'string' &&\n            parse(viewport.duration, 'ms') == null) {\n            throw new Error(`Unable to parse duration: '${viewport.duration}'`);\n        }\n    }\n};\n\nexport { validate as v };\n"],"names":["DEFAULT_CHART_CONFIG","widgetId","viewport","start","Date","end","yMin","yMax","size","width","height","marginLeft","marginRight","marginTop","marginBottom","movement","enableXScroll","enableYScroll","zoomMax","Infinity","zoomMin","layout","xGridVisible","yGridVisible","xTicksVisible","yTicksVisible","scale","xScaleType","ScaleType","TimeSeries","yScaleType","Linear","xScaleSide","yScaleSide","dataStreams","legend","position","LEGEND_POSITION","BOTTOM","DEFAULT_THRESHOLD_OPTIONS","showColor","DEFAULT_THRESHOLD_OPTIONS_OFF","pointVert","concat","MAX_THRESHOLD_BANDS","thresholdBands","thresholds","length","numberThresholds","getNumberThresholds","sortedThresholds","sortThreshold","reverse","bands","thresholdBandsSet","Set","forEach","threshold","index","thresholdValue","value","comparisonOperator","COMPARISON_OPERATOR","EQUAL","prevThreshold","prevThresholdValue","midPoint","breachedThreshold","getBreachedThreshold","has","_getCSSColorByString5","getCSSColorByString","color","_getCSSColorByString6","_slicedToArray","r","g","b","push","upper","lower","add","nexThresholdValue","_getCSSColorByString9","_getCSSColorByString10","Number","MIN_SAFE_INTEGER","_getCSSColorByString7","_getCSSColorByString8","MAX_SAFE_INTEGER","_getCSSColorByString3","_getCSSColorByString4","_getCSSColorByString","_getCSSColorByString2","lastThresholdBand","_getCSSColorByString11","_getCSSColorByString12","colorationShaderFrag","POINT_MESH_INDEX","pointDiameter","resolution","NUM_POSITION_COMPONENTS","updateGeometry","geometry","toClipSpace","allVertices","filter","isNumberDataStream","map","stream","vertices","flat","_geometry$attributes","attributes","pointColor","_ref","i","_ref2","x","y","array","setDrawRange","needsUpdate","pointMesh","_ref3","minBufferSize","bufferFactor","thresholdOptions","bufferSize","Math","max","numDataPoints","BufferGeometry","setAttribute","BufferAttribute","Float32Array","Uint8Array","initializeGeometry","_thresholdOptions$sho","material","ShaderMaterial","vertexShader","fragmentShader","transparent","uniforms","devicePixelRatio","window","points","Points","frustumCulled","updatePointMesh","hasDataChanged","arguments","undefined","chartScene","container","onUpdate","scene","Scene","clipSpaceConversion","meshList","mesh","constructChartScene","updateChartScene","chartSize","hasAnnotationChanged","children","isDataOverflowingBuffer","maxDataPointsRendered","needsNewClipSpace","tooltip","props","h","Object","assign","visualizesAlarms","supportString","dataAlignment","DATA_ALIGNMENT","EITHER","ScScatterChart","hostRef","_classCallCheck","registerInstance","this","gestures","isEditing","_createClass","key","validate","_this","renderFunc","rect","supportedDataTypes","DataType","NUMBER","axis","configId","annotations","trends","createChartScene","alarms","renderTooltip","messageOverrides","assertString_1","createCommonjsModule","module","exports","_typeof","obj","Symbol","iterator","constructor","prototype","defineProperty","default","input","String","invalidType","name","TypeError","isISO8601_1","str","options","_assertString","check","strictSeparator","iso8601StrictSeparator","test","iso8601","strict","isValidDate","__esModule","ordinalMatch","match","oYear","oDay","year","month","day","monthString","slice","dayString","d","getUTCFullYear","getUTCMonth","getUTCDate","isISO8601","getDefaultExportFromCjs","date","isMinimalStaticViewport","duration","console","warn","Error","parse"],"sourceRoot":""}