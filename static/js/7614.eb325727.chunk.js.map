{"version":3,"file":"static/js/7614.eb325727.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/chartScene-baf0ad0b.js","../node_modules/@iot-app-kit/components/dist/esm/chartSize-74a4bea8.js","../node_modules/@iot-app-kit/components/dist/esm/getDistanceFromDuration-67232b99.js","../node_modules/@iot-app-kit/components/dist/esm/sc-single-colored-bar.entry.js"],"sourcesContent":["import { I as InstancedBufferGeometry, R as RawShaderMaterial, D as DoubleSide, a as InstancedMesh, B as BufferAttribute, b as InstancedBufferAttribute, S as Scene } from './three.module-8c8bcb27.js';\nimport { n as numDataPoints, v as vertices, g as getCSSColorByString, c as constructChartScene, a as clipSpaceConversion, b as needsNewClipSpace } from './clipSpaceConversion-9fa25666.js';\nimport { g as getDistanceFromDuration } from './getDistanceFromDuration-67232b99.js';\nimport { g as getBreachedThreshold } from './utils-0919edc8.js';\nimport { b as isNumberDataStream } from './predicates-248e16b2.js';\n\n/* eslint-disable max-len */\nconst barVert = `\nprecision highp float;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float width;\nattribute vec2 bar;\nattribute vec2 position;\nattribute vec3 color;\nvarying vec3 vColor;\n\nvoid main() {\n  // Negative width here because we want to render the bars' width to the left side starting from its x position.\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x * -width + bar.x, position.y * bar.y, 0.0, 1.0);\n  vColor = color;\n}\n`;\n\nconst barFrag = `\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n`;\n\n/**\n * Display Constants\n *\n * Adjust these to scale the margins provided within the bar chart.\n * This represent which fraction of the 'width' of a given bar group a margin.\n */\nconst MARGIN_FACTOR = 1 / 6;\nconst getBarMargin = (toClipSpace, resolution) => getDistanceFromDuration(toClipSpace, resolution * MARGIN_FACTOR);\n/**\n * Get the bar width\n *\n * Returns the clipSpace width which each bar should be.\n * It is assumed that each bar within a group will have the same width.\n */\nconst getBarWidth = ({ toClipSpace, resolution, numDataStreams, }) => {\n    return (getDistanceFromDuration(toClipSpace, resolution) - getBarMargin(toClipSpace, resolution)) / numDataStreams;\n};\n\n// Used to set the default buffer size for a given chart - the larger this is set to, the more memory will be allocated\n// up front per `ChartScene`.\nconst NUM_POSITION_COMPONENTS = 2; // (x, y)\nconst NUM_COLOR_COMPONENTS = 3; // (r, g, b)\nconst numBars = (streamVertexSets) => {\n    return streamVertexSets.reduce((totalBars, streamVertexSet) => totalBars + streamVertexSet.length, 0);\n};\nconst getUniformWidth = (dataStreams, toClipSpace) => {\n    if (dataStreams.length === 0) {\n        return 0;\n    }\n    const { resolution } = dataStreams[0];\n    return getBarWidth({\n        toClipSpace,\n        numDataStreams: dataStreams.length,\n        resolution,\n    });\n};\nconst updateMesh = ({ dataStreams, mesh, toClipSpace, thresholds, thresholdOptions, }) => {\n    const streamVertexSets = dataStreams.filter(isNumberDataStream).map(stream => vertices(stream, stream.resolution));\n    // Set the number of instances of the bar are to be rendered.\n    // eslint-disable-next-line no-param-reassign\n    mesh.count = numBars(streamVertexSets);\n    const { geometry } = mesh;\n    const { color, bar } = geometry.attributes;\n    let positionIndex = 0;\n    let colorIndex = 0;\n    streamVertexSets.forEach((streamVertexSet, setIndex) => {\n        streamVertexSet.forEach(currVertex => {\n            const [currX, currY, r, g, b] = currVertex;\n            /**\n             * Subtracting setIndex * getUniformWidth(dataStreams, toClipSpace) because with each new\n             * data stream, we want to render it side by side on the left side.\n             */\n            bar.array[positionIndex] = toClipSpace(currX) - setIndex * getUniformWidth(dataStreams, toClipSpace);\n            bar.array[positionIndex + 1] = currY;\n            const breachedThreshold = getBreachedThreshold(currY, thresholds);\n            if (breachedThreshold == null || !thresholdOptions.showColor) {\n                // Set bar color (r, g, b)\n                color.array[colorIndex] = r;\n                color.array[colorIndex + 1] = g;\n                color.array[colorIndex + 2] = b;\n            }\n            else {\n                const [rr, gg, bb] = getCSSColorByString(breachedThreshold.color);\n                // Set bar color (r, g, b)\n                color.array[colorIndex] = rr;\n                color.array[colorIndex + 1] = gg;\n                color.array[colorIndex + 2] = bb;\n            }\n            // Increment Indexes by the associated stride of the buffer\n            colorIndex += NUM_COLOR_COMPONENTS;\n            positionIndex += NUM_POSITION_COMPONENTS;\n        });\n    });\n    bar.needsUpdate = true;\n    color.needsUpdate = true;\n};\n// https://wwwtyro.net/2019/11/18/instanced-lines.html\n// 2d vertices composing of two triangles which make up a square\n// (0, 1) - - - (1, 1)\n//   |  \\         |\n//   |     \\      |\n//   |        \\   |\n// (0, 0) - - - (1, 0)\nconst unitSquare = [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1];\nconst initializeGeometry = (geometry, bufferSize) => {\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(unitSquare), NUM_POSITION_COMPONENTS));\n    geometry.setAttribute('bar', new InstancedBufferAttribute(new Float32Array(bufferSize * NUM_POSITION_COMPONENTS), NUM_POSITION_COMPONENTS, false));\n    geometry.setAttribute('color', new InstancedBufferAttribute(new Uint8Array(bufferSize * NUM_COLOR_COMPONENTS), NUM_COLOR_COMPONENTS, true));\n};\nconst barMesh = ({ dataStreams, toClipSpace, bufferFactor, minBufferSize, thresholdOptions, thresholds, }) => {\n    const instGeo = new InstancedBufferGeometry();\n    const bufferSize = Math.max(minBufferSize, numDataPoints(dataStreams) * bufferFactor);\n    // Create and populate geometry\n    initializeGeometry(instGeo, bufferSize);\n    /**\n     * Create Bar Mesh\n     *\n     * The representation of the bars on a bar chart.\n     *\n     * Utilizes an instance of a single unit square, which then gets\n     * stretched and transposed across the canvas.\n     */\n    const barChartMaterial = new RawShaderMaterial({\n        vertexShader: barVert,\n        fragmentShader: barFrag,\n        side: DoubleSide,\n        transparent: false,\n        uniforms: {\n            width: {\n                value: getUniformWidth(dataStreams, toClipSpace),\n            },\n        },\n    });\n    const mesh = new InstancedMesh(instGeo, barChartMaterial, bufferSize);\n    updateMesh({ dataStreams, mesh, toClipSpace, thresholds, thresholdOptions });\n    // Prevent bounding sphere from being called\n    mesh.frustumCulled = false;\n    return mesh;\n};\nconst updateBarMesh = ({ bars, dataStreams, toClipSpace, hasDataChanged, thresholdOptions, thresholds, }) => {\n    if (hasDataChanged) {\n        // eslint-disable-next-line no-param-reassign\n        bars.material.uniforms.width.value = getUniformWidth(dataStreams, toClipSpace);\n        updateMesh({ dataStreams, mesh: bars, toClipSpace, thresholds, thresholdOptions });\n    }\n};\n\nconst maxDataPointsRendered = (bars) => bars.geometry.attributes.bar.array.length / NUM_POSITION_COMPONENTS;\nconst chartScene = ({ dataStreams, container, viewport, bufferFactor, minBufferSize, onUpdate, thresholdOptions, thresholds, }) => {\n    const scene = new Scene();\n    const toClipSpace = clipSpaceConversion(viewport);\n    scene.add(barMesh({ dataStreams, toClipSpace, bufferFactor, minBufferSize, thresholdOptions, thresholds }));\n    return constructChartScene({ scene, viewport, container, toClipSpace, onUpdate });\n};\nconst updateChartScene = ({ scene, dataStreams, hasDataChanged, minBufferSize, bufferFactor, viewport, container, onUpdate, chartSize, thresholdOptions, thresholds, hasAnnotationChanged, }) => {\n    const bars = scene.scene.children[0];\n    // If the amount of data being sent to the chart scene surpasses the size of the buffers within the\n    // chart scene, we must fully recreate the chart scene. This is a costly operation.\n    const isDataOverflowingBuffer = maxDataPointsRendered(bars) < numDataPoints(dataStreams);\n    if (isDataOverflowingBuffer || needsNewClipSpace(viewport, scene.toClipSpace) || hasAnnotationChanged) {\n        return chartScene({\n            onUpdate,\n            dataStreams,\n            container,\n            viewport,\n            minBufferSize,\n            bufferFactor,\n            chartSize,\n            thresholdOptions,\n            thresholds,\n        });\n    }\n    updateBarMesh({\n        bars,\n        dataStreams,\n        toClipSpace: scene.toClipSpace,\n        hasDataChanged,\n        thresholdOptions,\n        thresholds,\n    });\n    return scene;\n};\n\nexport { chartScene as c, updateChartScene as u };\n","const CHART_SIZE = {\n    width: 100,\n    height: 100,\n};\n\nexport { CHART_SIZE as C };\n","/**\n *\n * Get Distance from Duration\n *\n * Return distance between `milliseconds` on a given `xScale`, assuming `xScale` is linear.\n * If `xScale` is not linear, the distance between two points can depend on the exact value of time,\n * rather than just the time between. Non-linear `xScale` requires the width to be computed for every point rather\n * than just once.\n *\n * Since a non-linear xAxis is an un-common use case we won't support that for now.\n */\nconst getDistanceFromDuration = (toClipSpace, milliseconds) => Math.abs(toClipSpace(new Date(milliseconds).getTime()) - toClipSpace(new Date(0).getTime()));\n\nexport { getDistanceFromDuration as g };\n","import { r as registerInstance, h, g as getElement } from './index-1cec361c.js';\nimport { w as webGLRenderer } from './webglContext-6c9fd90d.js';\nimport { c as chartScene } from './chartScene-baf0ad0b.js';\nimport { C as CHART_SIZE } from './chartSize-74a4bea8.js';\nimport { D as DAY_IN_MS } from './time-b684d8c5.js';\nimport { D as DataType } from './dataConstants-71f11842.js';\nimport './three.module-8c8bcb27.js';\nimport './predicates-248e16b2.js';\nimport './clipSpaceConversion-9fa25666.js';\nimport './v4-b6bb7e11.js';\nimport './_commonjsHelpers-f9dc4873.js';\nimport './getDataPoints-c53771e0.js';\nimport './index-42a9af88.js';\nimport './getDistanceFromDuration-67232b99.js';\nimport './utils-0919edc8.js';\nimport './number-3e8376bf.js';\nimport './constants-9d5458e0.js';\nimport './bisector-ecf52045.js';\nimport './index-b3f1c3a1.js';\n\n// viewport boundaries\nconst X_MIN = new Date(2000, 0, 0);\nconst X_MAX = new Date(2000, 0, 1);\nconst Y_MIN = 0;\nconst Y_MAX = 100;\nconst WIDTH = X_MAX.getTime() - X_MIN.getTime();\nconst HEIGHT = Y_MAX - Y_MIN;\nconst TEST_DATA_POINT_1 = {\n  x: new Date(X_MIN.getTime() + WIDTH / 3).getTime(),\n  y: Y_MIN + HEIGHT / 2,\n};\nconst ScSingleColoredBar = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n  }\n  componentDidLoad() {\n    const container = this.el.querySelector('#test-container');\n    const scene = chartScene({\n      viewport: {\n        start: X_MIN,\n        end: X_MAX,\n        yMin: Y_MIN,\n        yMax: Y_MAX,\n      },\n      dataStreams: [\n        {\n          id: 'test-stream',\n          name: 'test-stream-name',\n          color: 'red',\n          resolution: DAY_IN_MS,\n          data: [],\n          aggregates: {\n            [DAY_IN_MS]: [TEST_DATA_POINT_1],\n          },\n          dataType: DataType.NUMBER,\n        },\n      ],\n      container,\n      chartSize: CHART_SIZE,\n      minBufferSize: 100,\n      bufferFactor: 2,\n      thresholdOptions: {\n        showColor: false,\n      },\n      thresholds: [],\n    });\n    webGLRenderer.addChartScene({ manager: scene });\n    const rect = container.getBoundingClientRect();\n    webGLRenderer.setChartRect(scene.id, Object.assign({ density: 1 }, rect.toJSON()));\n  }\n  render() {\n    return (h(\"sc-webgl-context\", null, h(\"div\", { id: \"test-container\", style: { width: `${CHART_SIZE.width}px`, height: `${CHART_SIZE.height}px` } })));\n  }\n  get el() { return getElement(this); }\n};\n\nexport { ScSingleColoredBar as sc_single_colored_bar };\n"],"names":["getBarWidth","_ref","toClipSpace","resolution","numDataStreams","getDistanceFromDuration","getBarMargin","getUniformWidth","dataStreams","length","updateMesh","_ref2","mesh","thresholds","thresholdOptions","streamVertexSets","filter","isNumberDataStream","map","stream","vertices","count","reduce","totalBars","streamVertexSet","numBars","_geometry$attributes","geometry","attributes","color","bar","positionIndex","colorIndex","forEach","setIndex","currVertex","_currVertex","_slicedToArray","currX","currY","r","g","b","array","breachedThreshold","getBreachedThreshold","showColor","_getCSSColorByString","getCSSColorByString","_getCSSColorByString2","rr","gg","bb","needsUpdate","unitSquare","barMesh","_ref3","bufferFactor","minBufferSize","instGeo","InstancedBufferGeometry","bufferSize","Math","max","numDataPoints","setAttribute","BufferAttribute","Float32Array","InstancedBufferAttribute","Uint8Array","initializeGeometry","barChartMaterial","RawShaderMaterial","vertexShader","fragmentShader","side","DoubleSide","transparent","uniforms","width","value","InstancedMesh","frustumCulled","chartScene","_ref5","container","viewport","onUpdate","scene","Scene","clipSpaceConversion","add","constructChartScene","updateChartScene","_ref6","hasDataChanged","chartSize","hasAnnotationChanged","bars","children","isDataOverflowingBuffer","maxDataPointsRendered","needsNewClipSpace","_ref4","material","updateBarMesh","CHART_SIZE","height","milliseconds","abs","Date","getTime","X_MIN","X_MAX","WIDTH","TEST_DATA_POINT_1","x","y","Y_MIN","ScSingleColoredBar","hostRef","_classCallCheck","registerInstance","this","_createClass","key","el","querySelector","start","end","yMin","yMax","id","name","DAY_IN_MS","data","aggregates","_defineProperty","dataType","DataType","NUMBER","webGLRenderer","addChartScene","manager","rect","getBoundingClientRect","setChartRect","Object","assign","density","toJSON","h","style","concat","get","getElement"],"sourceRoot":""}