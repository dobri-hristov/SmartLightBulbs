{"version":3,"file":"static/js/9311.0b15a754.chunk.js","mappings":"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","sources":["../node_modules/@iot-app-kit/components/dist/esm/iot-test-routes_4.entry.js"],"sourcesContent":["import { r as registerInstance, h, g as getElement, a as getContext } from './index-1cec361c.js';\nimport { m as matchPath, a as matchesAreEqual, s as storageAvailable, b as supportsHistory, c as supportsPopStateOnHashChange, d as stripTrailingSlash, e as addLeadingSlash, f as createLocation, g as createKey, h as hasBasename, i as stripBasename, j as createPath, k as getConfirmation, l as isExtraneousPopstateEvent, n as supportsGoWithoutReloadUsingHash, o as stripLeadingSlash, p as locationsAreEqual } from './dom-utils-97f33dea.js';\nimport { A as ActiveRouter } from './active-router-8f9f6b80.js';\n\nconst routes = [\n  {\n    url: '/',\n    component: 'testing-ground-app-kit',\n  },\n  {\n    url: '/resource-explorer/tree-table',\n    component: 'iot-tree-table-demo',\n  },\n  {\n    url: '/resource-explorer/',\n    component: 'iot-resource-explorer-demo',\n  },\n];\n\nconst IotTestRoutes = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n  }\n  render() {\n    return (h(\"stencil-router\", null, h(\"stencil-route-switch\", { scrollTopOffset: 0 }, routes.map((r) => (h(\"stencil-route\", { key: r.url, url: r.url, component: r.component, exact: true }))))));\n  }\n};\n\nconst routeCss = \"stencil-route.inactive{display:none}\";\n\nconst Route = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.group = null;\n    this.match = null;\n    this.componentProps = {};\n    this.exact = false;\n    this.scrollOnNextRender = false;\n    this.previousMatch = null;\n  }\n  // Identify if the current route is a match.\n  computeMatch(newLocation) {\n    const isGrouped = this.group != null || (this.el.parentElement != null && this.el.parentElement.tagName.toLowerCase() === 'stencil-route-switch');\n    if (!newLocation || isGrouped) {\n      return;\n    }\n    this.previousMatch = this.match;\n    return this.match = matchPath(newLocation.pathname, {\n      path: this.url,\n      exact: this.exact,\n      strict: true\n    });\n  }\n  async loadCompleted() {\n    let routeViewOptions = {};\n    if (this.history && this.history.location.hash) {\n      routeViewOptions = {\n        scrollToId: this.history.location.hash.substr(1)\n      };\n    }\n    else if (this.scrollTopOffset) {\n      routeViewOptions = {\n        scrollTopOffset: this.scrollTopOffset\n      };\n    }\n    // After all children have completed then tell switch\n    // the provided callback will get executed after this route is in view\n    if (typeof this.componentUpdated === 'function') {\n      this.componentUpdated(routeViewOptions);\n      // If this is an independent route and it matches then routes have updated.\n      // If the only change to location is a hash change then do not scroll.\n    }\n    else if (this.match && !matchesAreEqual(this.match, this.previousMatch) && this.routeViewsUpdated) {\n      this.routeViewsUpdated(routeViewOptions);\n    }\n  }\n  async componentDidUpdate() {\n    await this.loadCompleted();\n  }\n  async componentDidLoad() {\n    await this.loadCompleted();\n  }\n  render() {\n    // If there is no activeRouter then do not render\n    // Check if this route is in the matching URL (for example, a parent route)\n    if (!this.match || !this.history) {\n      return null;\n    }\n    // component props defined in route\n    // the history api\n    // current match data including params\n    const childProps = Object.assign({}, this.componentProps, { history: this.history, match: this.match });\n    // If there is a routerRender defined then use\n    // that and pass the component and component props with it.\n    if (this.routeRender) {\n      return this.routeRender(Object.assign({}, childProps, { component: this.component }));\n    }\n    if (this.component) {\n      const ChildComponent = this.component;\n      return (h(ChildComponent, Object.assign({}, childProps)));\n    }\n  }\n  get el() { return getElement(this); }\n  static get watchers() { return {\n    \"location\": [\"computeMatch\"]\n  }; }\n};\nActiveRouter.injectProps(Route, [\n  'location',\n  'history',\n  'historyType',\n  'routeViewsUpdated'\n]);\nRoute.style = routeCss;\n\nconst getUniqueId = () => {\n  return ((Math.random() * 10e16).toString().match(/.{4}/g) || []).join('-');\n};\nconst getMatch = (pathname, url, exact) => {\n  return matchPath(pathname, {\n    path: url,\n    exact: exact,\n    strict: true\n  });\n};\nconst isHTMLStencilRouteElement = (elm) => {\n  return elm.tagName === 'STENCIL-ROUTE';\n};\nconst RouteSwitch = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.group = getUniqueId();\n    this.subscribers = [];\n    this.queue = getContext(this, \"queue\");\n  }\n  componentWillLoad() {\n    if (this.location != null) {\n      this.regenerateSubscribers(this.location);\n    }\n  }\n  async regenerateSubscribers(newLocation) {\n    if (newLocation == null) {\n      return;\n    }\n    let newActiveIndex = -1;\n    this.subscribers = Array.prototype.slice.call(this.el.children)\n      .filter(isHTMLStencilRouteElement)\n      .map((childElement, index) => {\n      const match = getMatch(newLocation.pathname, childElement.url, childElement.exact);\n      if (match && newActiveIndex === -1) {\n        newActiveIndex = index;\n      }\n      return {\n        el: childElement,\n        match: match\n      };\n    });\n    if (newActiveIndex === -1) {\n      return;\n    }\n    // Check if this actually changes which child is active\n    // then just pass the new match down if the active route isn't changing.\n    if (this.activeIndex === newActiveIndex) {\n      this.subscribers[newActiveIndex].el.match = this.subscribers[newActiveIndex].match;\n      return;\n    }\n    this.activeIndex = newActiveIndex;\n    // Set all props on the new active route then wait until it says that it\n    // is completed\n    const activeChild = this.subscribers[this.activeIndex];\n    if (this.scrollTopOffset) {\n      activeChild.el.scrollTopOffset = this.scrollTopOffset;\n    }\n    activeChild.el.group = this.group;\n    activeChild.el.match = activeChild.match;\n    activeChild.el.componentUpdated = (routeViewUpdatedOptions) => {\n      // After the new active route has completed then update visibility of routes\n      this.queue.write(() => {\n        this.subscribers.forEach((child, index) => {\n          child.el.componentUpdated = undefined;\n          if (index === this.activeIndex) {\n            return child.el.style.display = '';\n          }\n          if (this.scrollTopOffset) {\n            child.el.scrollTopOffset = this.scrollTopOffset;\n          }\n          child.el.group = this.group;\n          child.el.match = null;\n          child.el.style.display = 'none';\n        });\n      });\n      if (this.routeViewsUpdated) {\n        this.routeViewsUpdated(Object.assign({ scrollTopOffset: this.scrollTopOffset }, routeViewUpdatedOptions));\n      }\n    };\n  }\n  render() {\n    return (h(\"slot\", null));\n  }\n  get el() { return getElement(this); }\n  static get watchers() { return {\n    \"location\": [\"regenerateSubscribers\"]\n  }; }\n};\nActiveRouter.injectProps(RouteSwitch, [\n  'location',\n  'routeViewsUpdated'\n]);\n\nconst warning = (value, ...args) => {\r\n    if (!value) {\r\n        console.warn(...args);\r\n    }\r\n};\n\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nconst createTransitionManager = () => {\r\n    let prompt;\r\n    let listeners = [];\r\n    const setPrompt = (nextPrompt) => {\r\n        warning(prompt == null, 'A history supports only one prompt at a time');\r\n        prompt = nextPrompt;\r\n        return () => {\r\n            if (prompt === nextPrompt) {\r\n                prompt = null;\r\n            }\r\n        };\r\n    };\r\n    const confirmTransitionTo = (location, action, getUserConfirmation, callback) => {\r\n        // TODO: If another transition starts while we're still confirming\r\n        // the previous one, we may end up in a weird state. Figure out the\r\n        // best way to handle this.\r\n        if (prompt != null) {\r\n            const result = typeof prompt === 'function' ? prompt(location, action) : prompt;\r\n            if (typeof result === 'string') {\r\n                if (typeof getUserConfirmation === 'function') {\r\n                    getUserConfirmation(result, callback);\r\n                }\r\n                else {\r\n                    warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\r\n                    callback(true);\r\n                }\r\n            }\r\n            else {\r\n                // Return false from a transition hook to cancel the transition.\r\n                callback(result !== false);\r\n            }\r\n        }\r\n        else {\r\n            callback(true);\r\n        }\r\n    };\r\n    const appendListener = (fn) => {\r\n        let isActive = true;\r\n        const listener = (...args) => {\r\n            if (isActive) {\r\n                fn(...args);\r\n            }\r\n        };\r\n        listeners.push(listener);\r\n        return () => {\r\n            isActive = false;\r\n            listeners = listeners.filter(item => item !== listener);\r\n        };\r\n    };\r\n    const notifyListeners = (...args) => {\r\n        listeners.forEach(listener => listener(...args));\r\n    };\r\n    return {\r\n        setPrompt,\r\n        confirmTransitionTo,\r\n        appendListener,\r\n        notifyListeners\r\n    };\r\n};\n\nconst createScrollHistory = (win, applicationScrollKey = 'scrollPositions') => {\r\n    let scrollPositions = new Map();\r\n    const set = (key, value) => {\r\n        scrollPositions.set(key, value);\r\n        if (storageAvailable(win, 'sessionStorage')) {\r\n            const arrayData = [];\r\n            scrollPositions.forEach((value, key) => {\r\n                arrayData.push([key, value]);\r\n            });\r\n            win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData));\r\n        }\r\n    };\r\n    const get = (key) => {\r\n        return scrollPositions.get(key);\r\n    };\r\n    const has = (key) => {\r\n        return scrollPositions.has(key);\r\n    };\r\n    const capture = (key) => {\r\n        set(key, [win.scrollX, win.scrollY]);\r\n    };\r\n    if (storageAvailable(win, 'sessionStorage')) {\r\n        const scrollData = win.sessionStorage.getItem(applicationScrollKey);\r\n        scrollPositions = scrollData ?\r\n            new Map(JSON.parse(scrollData)) :\r\n            scrollPositions;\r\n    }\r\n    if ('scrollRestoration' in win.history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    return {\r\n        set,\r\n        get,\r\n        has,\r\n        capture\r\n    };\r\n};\n\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nconst PopStateEvent = 'popstate';\r\nconst HashChangeEvent$1 = 'hashchange';\r\n/**\r\n * Creates a history object that uses the HTML5 history API including\r\n * pushState, replaceState, and the popstate event.\r\n */\r\nconst createBrowserHistory = (win, props = {}) => {\r\n    let forceNextPop = false;\r\n    const globalHistory = win.history;\r\n    const globalLocation = win.location;\r\n    const globalNavigator = win.navigator;\r\n    const canUseHistory = supportsHistory(win);\r\n    const needsHashChangeListener = !supportsPopStateOnHashChange(globalNavigator);\r\n    const scrollHistory = createScrollHistory(win);\r\n    const forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;\r\n    const getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : getConfirmation;\r\n    const keyLength = (props.keyLength != null) ? props.keyLength : 6;\r\n    const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n    const getHistoryState = () => {\r\n        try {\r\n            return win.history.state || {};\r\n        }\r\n        catch (e) {\r\n            // IE 11 sometimes throws when accessing window.history.state\r\n            // See https://github.com/ReactTraining/history/pull/289\r\n            return {};\r\n        }\r\n    };\r\n    const getDOMLocation = (historyState) => {\r\n        historyState = historyState || {};\r\n        const { key, state } = historyState;\r\n        const { pathname, search, hash } = globalLocation;\r\n        let path = pathname + search + hash;\r\n        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\r\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n        if (basename) {\r\n            path = stripBasename(path, basename);\r\n        }\r\n        return createLocation(path, state, key || createKey(keyLength));\r\n    };\r\n    const transitionManager = createTransitionManager();\r\n    const setState = (nextState) => {\r\n        // Capture location for the view before changing history.\r\n        scrollHistory.capture(history.location.key);\r\n        Object.assign(history, nextState);\r\n        // Set scroll position based on its previous storage value\r\n        history.location.scrollPosition = scrollHistory.get(history.location.key);\r\n        history.length = globalHistory.length;\r\n        transitionManager.notifyListeners(history.location, history.action);\r\n    };\r\n    const handlePopState = (event) => {\r\n        // Ignore extraneous popstate events in WebKit.\r\n        if (!isExtraneousPopstateEvent(globalNavigator, event)) {\r\n            handlePop(getDOMLocation(event.state));\r\n        }\r\n    };\r\n    const handleHashChange = () => {\r\n        handlePop(getDOMLocation(getHistoryState()));\r\n    };\r\n    const handlePop = (location) => {\r\n        if (forceNextPop) {\r\n            forceNextPop = false;\r\n            setState();\r\n        }\r\n        else {\r\n            const action = 'POP';\r\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n                if (ok) {\r\n                    setState({ action, location });\r\n                }\r\n                else {\r\n                    revertPop(location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const revertPop = (fromLocation) => {\r\n        const toLocation = history.location;\r\n        // TODO: We could probably make this more reliable by\r\n        // keeping a list of keys we've seen in sessionStorage.\r\n        // Instead, we just default to 0 for keys we don't know.\r\n        let toIndex = allKeys.indexOf(toLocation.key);\r\n        let fromIndex = allKeys.indexOf(fromLocation.key);\r\n        if (toIndex === -1) {\r\n            toIndex = 0;\r\n        }\r\n        if (fromIndex === -1) {\r\n            fromIndex = 0;\r\n        }\r\n        const delta = toIndex - fromIndex;\r\n        if (delta) {\r\n            forceNextPop = true;\r\n            go(delta);\r\n        }\r\n    };\r\n    const initialLocation = getDOMLocation(getHistoryState());\r\n    let allKeys = [initialLocation.key];\r\n    let listenerCount = 0;\r\n    let isBlocked = false;\r\n    // Public interface\r\n    const createHref = (location) => {\r\n        return basename + createPath(location);\r\n    };\r\n    const push = (path, state) => {\r\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +\r\n            'argument is a location-like object that already has state; it is ignored');\r\n        const action = 'PUSH';\r\n        const location = createLocation(path, state, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const href = createHref(location);\r\n            const { key, state } = location;\r\n            if (canUseHistory) {\r\n                globalHistory.pushState({ key, state }, '', href);\r\n                if (forceRefresh) {\r\n                    globalLocation.href = href;\r\n                }\r\n                else {\r\n                    const prevIndex = allKeys.indexOf(history.location.key);\r\n                    const nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n                    nextKeys.push(location.key);\r\n                    allKeys = nextKeys;\r\n                    setState({ action, location });\r\n                }\r\n            }\r\n            else {\r\n                warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\r\n                globalLocation.href = href;\r\n            }\r\n        });\r\n    };\r\n    const replace = (path, state) => {\r\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +\r\n            'argument is a location-like object that already has state; it is ignored');\r\n        const action = 'REPLACE';\r\n        const location = createLocation(path, state, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const href = createHref(location);\r\n            const { key, state } = location;\r\n            if (canUseHistory) {\r\n                globalHistory.replaceState({ key, state }, '', href);\r\n                if (forceRefresh) {\r\n                    globalLocation.replace(href);\r\n                }\r\n                else {\r\n                    const prevIndex = allKeys.indexOf(history.location.key);\r\n                    if (prevIndex !== -1) {\r\n                        allKeys[prevIndex] = location.key;\r\n                    }\r\n                    setState({ action, location });\r\n                }\r\n            }\r\n            else {\r\n                warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\r\n                globalLocation.replace(href);\r\n            }\r\n        });\r\n    };\r\n    const go = (n) => {\r\n        globalHistory.go(n);\r\n    };\r\n    const goBack = () => go(-1);\r\n    const goForward = () => go(1);\r\n    const checkDOMListeners = (delta) => {\r\n        listenerCount += delta;\r\n        if (listenerCount === 1) {\r\n            win.addEventListener(PopStateEvent, handlePopState);\r\n            if (needsHashChangeListener) {\r\n                win.addEventListener(HashChangeEvent$1, handleHashChange);\r\n            }\r\n        }\r\n        else if (listenerCount === 0) {\r\n            win.removeEventListener(PopStateEvent, handlePopState);\r\n            if (needsHashChangeListener) {\r\n                win.removeEventListener(HashChangeEvent$1, handleHashChange);\r\n            }\r\n        }\r\n    };\r\n    const block = (prompt = '') => {\r\n        const unblock = transitionManager.setPrompt(prompt);\r\n        if (!isBlocked) {\r\n            checkDOMListeners(1);\r\n            isBlocked = true;\r\n        }\r\n        return () => {\r\n            if (isBlocked) {\r\n                isBlocked = false;\r\n                checkDOMListeners(-1);\r\n            }\r\n            return unblock();\r\n        };\r\n    };\r\n    const listen = (listener) => {\r\n        const unlisten = transitionManager.appendListener(listener);\r\n        checkDOMListeners(1);\r\n        return () => {\r\n            checkDOMListeners(-1);\r\n            unlisten();\r\n        };\r\n    };\r\n    const history = {\r\n        length: globalHistory.length,\r\n        action: 'POP',\r\n        location: initialLocation,\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        goBack,\r\n        goForward,\r\n        block,\r\n        listen,\r\n        win: win\r\n    };\r\n    return history;\r\n};\n\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nconst HashChangeEvent = 'hashchange';\r\nconst HashPathCoders = {\r\n    hashbang: {\r\n        encodePath: (path) => path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path),\r\n        decodePath: (path) => path.charAt(0) === '!' ? path.substr(1) : path\r\n    },\r\n    noslash: {\r\n        encodePath: stripLeadingSlash,\r\n        decodePath: addLeadingSlash\r\n    },\r\n    slash: {\r\n        encodePath: addLeadingSlash,\r\n        decodePath: addLeadingSlash\r\n    }\r\n};\r\nconst createHashHistory = (win, props = {}) => {\r\n    let forceNextPop = false;\r\n    let ignorePath = null;\r\n    let listenerCount = 0;\r\n    let isBlocked = false;\r\n    const globalLocation = win.location;\r\n    const globalHistory = win.history;\r\n    const canGoWithoutReload = supportsGoWithoutReloadUsingHash(win.navigator);\r\n    const keyLength = (props.keyLength != null) ? props.keyLength : 6;\r\n    const { getUserConfirmation = getConfirmation, hashType = 'slash' } = props;\r\n    const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n    const { encodePath, decodePath } = HashPathCoders[hashType];\r\n    const getHashPath = () => {\r\n        // We can't use window.location.hash here because it's not\r\n        // consistent across browsers - Firefox will pre-decode it!\r\n        const href = globalLocation.href;\r\n        const hashIndex = href.indexOf('#');\r\n        return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\r\n    };\r\n    const pushHashPath = (path) => (globalLocation.hash = path);\r\n    const replaceHashPath = (path) => {\r\n        const hashIndex = globalLocation.href.indexOf('#');\r\n        globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\r\n    };\r\n    const getDOMLocation = () => {\r\n        let path = decodePath(getHashPath());\r\n        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\r\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n        if (basename) {\r\n            path = stripBasename(path, basename);\r\n        }\r\n        return createLocation(path, undefined, createKey(keyLength));\r\n    };\r\n    const transitionManager = createTransitionManager();\r\n    const setState = (nextState) => {\r\n        Object.assign(history, nextState);\r\n        history.length = globalHistory.length;\r\n        transitionManager.notifyListeners(history.location, history.action);\r\n    };\r\n    const handleHashChange = () => {\r\n        const path = getHashPath();\r\n        const encodedPath = encodePath(path);\r\n        if (path !== encodedPath) {\r\n            // Ensure we always have a properly-encoded hash.\r\n            replaceHashPath(encodedPath);\r\n        }\r\n        else {\r\n            const location = getDOMLocation();\r\n            const prevLocation = history.location;\r\n            if (!forceNextPop && locationsAreEqual(prevLocation, location)) {\r\n                return; // A hashchange doesn't always == location change.\r\n            }\r\n            if (ignorePath === createPath(location)) {\r\n                return; // Ignore this change; we already setState in push/replace.\r\n            }\r\n            ignorePath = null;\r\n            handlePop(location);\r\n        }\r\n    };\r\n    const handlePop = (location) => {\r\n        if (forceNextPop) {\r\n            forceNextPop = false;\r\n            setState();\r\n        }\r\n        else {\r\n            const action = 'POP';\r\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n                if (ok) {\r\n                    setState({ action, location });\r\n                }\r\n                else {\r\n                    revertPop(location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const revertPop = (fromLocation) => {\r\n        const toLocation = history.location;\r\n        // TODO: We could probably make this more reliable by\r\n        // keeping a list of paths we've seen in sessionStorage.\r\n        // Instead, we just default to 0 for paths we don't know.\r\n        let toIndex = allPaths.lastIndexOf(createPath(toLocation));\r\n        let fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\r\n        if (toIndex === -1) {\r\n            toIndex = 0;\r\n        }\r\n        if (fromIndex === -1) {\r\n            fromIndex = 0;\r\n        }\r\n        const delta = toIndex - fromIndex;\r\n        if (delta) {\r\n            forceNextPop = true;\r\n            go(delta);\r\n        }\r\n    };\r\n    // Ensure the hash is encoded properly before doing anything else.\r\n    const path = getHashPath();\r\n    const encodedPath = encodePath(path);\r\n    if (path !== encodedPath) {\r\n        replaceHashPath(encodedPath);\r\n    }\r\n    const initialLocation = getDOMLocation();\r\n    let allPaths = [createPath(initialLocation)];\r\n    // Public interface\r\n    const createHref = (location) => ('#' + encodePath(basename + createPath(location)));\r\n    const push = (path, state) => {\r\n        warning(state === undefined, 'Hash history cannot push state; it is ignored');\r\n        const action = 'PUSH';\r\n        const location = createLocation(path, undefined, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const path = createPath(location);\r\n            const encodedPath = encodePath(basename + path);\r\n            const hashChanged = getHashPath() !== encodedPath;\r\n            if (hashChanged) {\r\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\r\n                // rather setState here and ignore the hashchange. The caveat here\r\n                // is that other hash histories in the page will consider it a POP.\r\n                ignorePath = path;\r\n                pushHashPath(encodedPath);\r\n                const prevIndex = allPaths.lastIndexOf(createPath(history.location));\r\n                const nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n                nextPaths.push(path);\r\n                allPaths = nextPaths;\r\n                setState({ action, location });\r\n            }\r\n            else {\r\n                warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\r\n                setState();\r\n            }\r\n        });\r\n    };\r\n    const replace = (path, state) => {\r\n        warning(state === undefined, 'Hash history cannot replace state; it is ignored');\r\n        const action = 'REPLACE';\r\n        const location = createLocation(path, undefined, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const path = createPath(location);\r\n            const encodedPath = encodePath(basename + path);\r\n            const hashChanged = getHashPath() !== encodedPath;\r\n            if (hashChanged) {\r\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\r\n                // rather setState here and ignore the hashchange. The caveat here\r\n                // is that other hash histories in the page will consider it a POP.\r\n                ignorePath = path;\r\n                replaceHashPath(encodedPath);\r\n            }\r\n            const prevIndex = allPaths.indexOf(createPath(history.location));\r\n            if (prevIndex !== -1) {\r\n                allPaths[prevIndex] = path;\r\n            }\r\n            setState({ action, location });\r\n        });\r\n    };\r\n    const go = (n) => {\r\n        warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\r\n        globalHistory.go(n);\r\n    };\r\n    const goBack = () => go(-1);\r\n    const goForward = () => go(1);\r\n    const checkDOMListeners = (win, delta) => {\r\n        listenerCount += delta;\r\n        if (listenerCount === 1) {\r\n            win.addEventListener(HashChangeEvent, handleHashChange);\r\n        }\r\n        else if (listenerCount === 0) {\r\n            win.removeEventListener(HashChangeEvent, handleHashChange);\r\n        }\r\n    };\r\n    const block = (prompt = '') => {\r\n        const unblock = transitionManager.setPrompt(prompt);\r\n        if (!isBlocked) {\r\n            checkDOMListeners(win, 1);\r\n            isBlocked = true;\r\n        }\r\n        return () => {\r\n            if (isBlocked) {\r\n                isBlocked = false;\r\n                checkDOMListeners(win, -1);\r\n            }\r\n            return unblock();\r\n        };\r\n    };\r\n    const listen = (listener) => {\r\n        const unlisten = transitionManager.appendListener(listener);\r\n        checkDOMListeners(win, 1);\r\n        return () => {\r\n            checkDOMListeners(win, -1);\r\n            unlisten();\r\n        };\r\n    };\r\n    const history = {\r\n        length: globalHistory.length,\r\n        action: 'POP',\r\n        location: initialLocation,\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        goBack,\r\n        goForward,\r\n        block,\r\n        listen,\r\n        win: win\r\n    };\r\n    return history;\r\n};\n\nconst getLocation = (location, root) => {\n  // Remove the root URL if found at beginning of string\n  const pathname = location.pathname.indexOf(root) == 0 ?\n    '/' + location.pathname.slice(root.length) :\n    location.pathname;\n  return Object.assign({}, location, { pathname });\n};\nconst HISTORIES = {\n  'browser': createBrowserHistory,\n  'hash': createHashHistory\n};\nconst Router = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.root = '/';\n    this.historyType = 'browser';\n    // A suffix to append to the page title whenever\n    // it's updated through RouteTitle\n    this.titleSuffix = '';\n    this.routeViewsUpdated = (options = {}) => {\n      if (this.history && options.scrollToId && this.historyType === 'browser') {\n        const elm = this.history.win.document.getElementById(options.scrollToId);\n        if (elm) {\n          return elm.scrollIntoView();\n        }\n      }\n      this.scrollTo(options.scrollTopOffset || this.scrollTopOffset);\n    };\n    this.isServer = getContext(this, \"isServer\");\n    this.queue = getContext(this, \"queue\");\n  }\n  componentWillLoad() {\n    this.history = HISTORIES[this.historyType](this.el.ownerDocument.defaultView);\n    this.history.listen((location) => {\n      location = getLocation(location, this.root);\n      this.location = location;\n    });\n    this.location = getLocation(this.history.location, this.root);\n  }\n  scrollTo(scrollToLocation) {\n    const history = this.history;\n    if (scrollToLocation == null || this.isServer || !history) {\n      return;\n    }\n    if (history.action === 'POP' && Array.isArray(history.location.scrollPosition)) {\n      return this.queue.write(() => {\n        if (history && history.location && Array.isArray(history.location.scrollPosition)) {\n          history.win.scrollTo(history.location.scrollPosition[0], history.location.scrollPosition[1]);\n        }\n      });\n    }\n    // okay, the frame has passed. Go ahead and render now\n    return this.queue.write(() => {\n      history.win.scrollTo(0, scrollToLocation);\n    });\n  }\n  render() {\n    if (!this.location || !this.history) {\n      return;\n    }\n    const state = {\n      historyType: this.historyType,\n      location: this.location,\n      titleSuffix: this.titleSuffix,\n      root: this.root,\n      history: this.history,\n      routeViewsUpdated: this.routeViewsUpdated\n    };\n    return (h(ActiveRouter.Provider, { state: state }, h(\"slot\", null)));\n  }\n  get el() { return getElement(this); }\n};\n\nexport { IotTestRoutes as iot_test_routes, Route as stencil_route, RouteSwitch as stencil_route_switch, Router as stencil_router };\n"],"names":["routes","url","component","IotTestRoutes","hostRef","_classCallCheck","registerInstance","this","_createClass","key","value","h","scrollTopOffset","map","r","exact","Route","group","match","componentProps","scrollOnNextRender","previousMatch","newLocation","isGrouped","el","parentElement","tagName","toLowerCase","matchPath","pathname","path","strict","_loadCompleted","_asyncToGenerator","_regeneratorRuntime","mark","_callee","routeViewOptions","wrap","_context","prev","next","history","location","hash","scrollToId","substr","componentUpdated","matchesAreEqual","routeViewsUpdated","stop","apply","arguments","_componentDidUpdate","_callee2","_context2","loadCompleted","_componentDidLoad","_callee3","_context3","childProps","Object","assign","routeRender","ChildComponent","get","getElement","ActiveRouter","injectProps","style","isHTMLStencilRouteElement","elm","RouteSwitch","Math","random","toString","join","subscribers","queue","getContext","regenerateSubscribers","_regenerateSubscribers","_callee4","newActiveIndex","activeChild","_this","_context4","abrupt","Array","prototype","slice","call","children","filter","childElement","index","activeIndex","routeViewUpdatedOptions","write","forEach","child","undefined","display","_x","warning","_console","_len","length","args","_key","console","warn","createTransitionManager","prompt","listeners","setPrompt","nextPrompt","confirmTransitionTo","action","getUserConfirmation","callback","result","appendListener","fn","isActive","listener","push","item","notifyListeners","_len2","_key2","createScrollHistory","win","applicationScrollKey","scrollPositions","Map","set","storageAvailable","arrayData","sessionStorage","setItem","JSON","stringify","scrollData","getItem","parse","scrollRestoration","has","capture","scrollX","scrollY","PopStateEvent","HashChangeEvent$1","HashChangeEvent","HashPathCoders","hashbang","encodePath","charAt","stripLeadingSlash","decodePath","noslash","addLeadingSlash","slash","getLocation","root","indexOf","HISTORIES","props","forceNextPop","globalHistory","globalLocation","globalNavigator","navigator","canUseHistory","supportsHistory","needsHashChangeListener","supportsPopStateOnHashChange","scrollHistory","forceRefresh","getConfirmation","keyLength","basename","stripTrailingSlash","getHistoryState","state","e","getDOMLocation","historyState","_historyState","search","hasBasename","stripBasename","createLocation","createKey","transitionManager","setState","nextState","scrollPosition","handlePopState","event","isExtraneousPopstateEvent","handlePop","handleHashChange","ok","revertPop","fromLocation","toLocation","toIndex","allKeys","fromIndex","delta","go","initialLocation","listenerCount","isBlocked","createHref","createPath","n","checkDOMListeners","addEventListener","removeEventListener","href","pushState","prevIndex","nextKeys","replace","replaceState","goBack","goForward","block","unblock","listen","unlisten","ignorePath","canGoWithoutReload","supportsGoWithoutReloadUsingHash","_props$getUserConfirm","_props$hashType","hashType","_HashPathCoders$hashT","getHashPath","hashIndex","substring","replaceHashPath","encodedPath","prevLocation","locationsAreEqual","allPaths","lastIndexOf","pushHashPath","nextPaths","Router","_this2","historyType","titleSuffix","options","document","getElementById","scrollIntoView","scrollTo","isServer","_this3","ownerDocument","defaultView","scrollToLocation","isArray","Provider"],"sourceRoot":""}